// Code generated from antlr/v0-29-x/SqlBase.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // SqlBase

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SqlBaseParser struct {
	*antlr.BaseParser
}

var SqlBaseParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func sqlbaseParserInit() {
	staticData := &SqlBaseParserStaticData
	staticData.LiteralNames = []string{
		"", "';'", "','", "'('", "')'", "'.'", "'['", "']'", "'STRING'", "'EMIT'",
		"'CHANGES'", "'FINAL'", "'SELECT'", "'FROM'", "'AS'", "'ALL'", "'DISTINCT'",
		"'WHERE'", "'WITHIN'", "'WINDOW'", "'GROUP'", "'BY'", "'HAVING'", "'LIMIT'",
		"'AT'", "'OR'", "'AND'", "'IN'", "'NOT'", "'EXISTS'", "'BETWEEN'", "'LIKE'",
		"'ESCAPE'", "'IS'", "'NULL'", "'TRUE'", "'FALSE'", "'INTEGER'", "'DATE'",
		"'TIME'", "'TIMESTAMP'", "'INTERVAL'", "'YEAR'", "'MONTH'", "'DAY'",
		"'HOUR'", "'MINUTE'", "'SECOND'", "'MILLISECOND'", "'YEARS'", "'MONTHS'",
		"'DAYS'", "'HOURS'", "'MINUTES'", "'SECONDS'", "'MILLISECONDS'", "'ZONE'",
		"'TUMBLING'", "'HOPPING'", "'SIZE'", "'ADVANCE'", "'RETENTION'", "'GRACE'",
		"'PERIOD'", "'CASE'", "'WHEN'", "'THEN'", "'ELSE'", "'END'", "'JOIN'",
		"'FULL'", "'OUTER'", "'INNER'", "'LEFT'", "'RIGHT'", "'ON'", "'PARTITION'",
		"'STRUCT'", "'WITH'", "'VALUES'", "'CREATE'", "'TABLE'", "'TOPIC'",
		"'STREAM'", "'STREAMS'", "'INSERT'", "'DELETE'", "'INTO'", "'DESCRIBE'",
		"'EXTENDED'", "'PRINT'", "'EXPLAIN'", "'ANALYZE'", "'TYPE'", "'TYPES'",
		"'CAST'", "'SHOW'", "'LIST'", "'TABLES'", "'TOPICS'", "'QUERY'", "'QUERIES'",
		"'TERMINATE'", "'PAUSE'", "'RESUME'", "'LOAD'", "'COLUMNS'", "'COLUMN'",
		"'PARTITIONS'", "'FUNCTIONS'", "'FUNCTION'", "'DROP'", "'TO'", "'RENAME'",
		"'ARRAY'", "'MAP'", "'SET'", "'DEFINE'", "'UNDEFINE'", "'RESET'", "'SESSION'",
		"'SAMPLE'", "'EXPORT'", "'CATALOG'", "'PROPERTIES'", "'BEGINNING'",
		"'UNSET'", "'RUN'", "'SCRIPT'", "'DECIMAL'", "'KEY'", "'CONNECTOR'",
		"'CONNECTORS'", "'SINK'", "'SOURCE'", "'NAMESPACE'", "'MATERIALIZED'",
		"'VIEW'", "'PRIMARY'", "'REPLACE'", "'ASSERT'", "'ADD'", "'ALTER'",
		"'VARIABLES'", "'PLUGINS'", "'HEADERS'", "'HEADER'", "'SYSTEM'", "'TIMEOUT'",
		"'SCHEMA'", "'SUBJECT'", "'ID'", "'IF'", "'='", "", "'<'", "'<='", "'>'",
		"'>='", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'", "':='", "'->'", "'=>'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "EMIT", "CHANGES", "FINAL", "SELECT",
		"FROM", "AS", "ALL", "DISTINCT", "WHERE", "WITHIN", "WINDOW", "GROUP",
		"BY", "HAVING", "LIMIT", "AT", "OR", "AND", "IN", "NOT", "EXISTS", "BETWEEN",
		"LIKE", "ESCAPE", "IS", "NULL", "TRUE", "FALSE", "INTEGER", "DATE",
		"TIME", "TIMESTAMP", "INTERVAL", "YEAR", "MONTH", "DAY", "HOUR", "MINUTE",
		"SECOND", "MILLISECOND", "YEARS", "MONTHS", "DAYS", "HOURS", "MINUTES",
		"SECONDS", "MILLISECONDS", "ZONE", "TUMBLING", "HOPPING", "SIZE", "ADVANCE",
		"RETENTION", "GRACE", "PERIOD", "CASE", "WHEN", "THEN", "ELSE", "END",
		"JOIN", "FULL", "OUTER", "INNER", "LEFT", "RIGHT", "ON", "PARTITION",
		"STRUCT", "WITH", "VALUES", "CREATE", "TABLE", "TOPIC", "STREAM", "STREAMS",
		"INSERT", "DELETE", "INTO", "DESCRIBE", "EXTENDED", "PRINT", "EXPLAIN",
		"ANALYZE", "TYPE", "TYPES", "CAST", "SHOW", "LIST", "TABLES", "TOPICS",
		"QUERY", "QUERIES", "TERMINATE", "PAUSE", "RESUME", "LOAD", "COLUMNS",
		"COLUMN", "PARTITIONS", "FUNCTIONS", "FUNCTION", "DROP", "TO", "RENAME",
		"ARRAY", "MAP", "SET", "DEFINE", "UNDEFINE", "RESET", "SESSION", "SAMPLE",
		"EXPORT", "CATALOG", "PROPERTIES", "BEGINNING", "UNSET", "RUN", "SCRIPT",
		"DECIMAL", "KEY", "CONNECTOR", "CONNECTORS", "SINK", "SOURCE", "NAMESPACE",
		"MATERIALIZED", "VIEW", "PRIMARY", "REPLACE", "ASSERT", "ADD", "ALTER",
		"VARIABLES", "PLUGINS", "HEADERS", "HEADER", "SYSTEM", "TIMEOUT", "SCHEMA",
		"SUBJECT", "ID", "IF", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "PLUS",
		"MINUS", "ASTERISK", "SLASH", "PERCENT", "CONCAT", "ASSIGN", "STRUCT_FIELD_REF",
		"LAMBDA_EXPRESSION", "STRING", "INTEGER_VALUE", "DECIMAL_VALUE", "FLOATING_POINT_VALUE",
		"IDENTIFIER", "DIGIT_IDENTIFIER", "QUOTED_IDENTIFIER", "BACKQUOTED_IDENTIFIER",
		"VARIABLE", "SIMPLE_COMMENT", "DIRECTIVE_COMMENT", "BRACKETED_COMMENT",
		"WS", "UNRECOGNIZED", "DELIMITER",
	}
	staticData.RuleNames = []string{
		"statements", "testStatement", "singleStatement", "singleExpression",
		"statement", "assertStatement", "runScript", "resourceName", "query",
		"resultMaterialization", "timeout", "alterOption", "tableElements",
		"tableElement", "columnConstraints", "tableProperties", "tableProperty",
		"printClause", "intervalClause", "limitClause", "retentionClause", "gracePeriodClause",
		"windowExpression", "tumblingWindowExpression", "hoppingWindowExpression",
		"sessionWindowExpression", "windowUnit", "groupBy", "partitionBy", "values",
		"selectItem", "relation", "joinedSource", "joinType", "joinWindow",
		"withinExpression", "joinWindowSize", "joinCriteria", "aliasedRelation",
		"columns", "relationPrimary", "expression", "booleanExpression", "predicated",
		"predicate", "valueExpression", "primaryExpression", "functionArgument",
		"timeZoneSpecifier", "comparisonOperator", "booleanValue", "type", "typeParameter",
		"baseType", "whenClause", "identifier", "lambdaFunction", "variableName",
		"variableValue", "sourceName", "number", "literal", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 182, 1201, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		1, 0, 5, 0, 128, 8, 0, 10, 0, 12, 0, 131, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 142, 8, 1, 1, 1, 3, 1, 145, 8, 1, 1,
		2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 158,
		8, 4, 1, 4, 1, 4, 3, 4, 162, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 167, 8, 4, 1,
		4, 1, 4, 1, 4, 3, 4, 172, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 178, 8, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4,
		191, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 196, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 211, 8, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 246, 8, 4, 1,
		4, 3, 4, 249, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 255, 8, 4, 1, 4, 1, 4,
		3, 4, 259, 8, 4, 1, 4, 1, 4, 3, 4, 263, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 268,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 274, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4,
		279, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 287, 8, 4, 1, 4, 3,
		4, 290, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 296, 8, 4, 1, 4, 1, 4, 3, 4,
		300, 8, 4, 1, 4, 1, 4, 3, 4, 304, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 309, 8,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 315, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 320,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 331,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 342,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 350, 8, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 359, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4,
		364, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 370, 8, 4, 1, 4, 1, 4, 1, 4, 3,
		4, 375, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 381, 8, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 3, 4, 387, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 394, 8, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 404, 8, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 413, 8, 4, 10, 4, 12, 4, 416, 9,
		4, 1, 4, 1, 4, 1, 4, 3, 4, 421, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 427,
		8, 4, 1, 4, 3, 4, 430, 8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 435, 8, 4, 1, 4, 1,
		4, 1, 4, 3, 4, 440, 8, 4, 1, 4, 1, 4, 3, 4, 444, 8, 4, 1, 4, 3, 4, 447,
		8, 4, 3, 4, 449, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 455, 8, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 465, 8, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 474, 8, 5, 1, 5, 1, 5, 3, 5, 478, 8, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 484, 8, 5, 1, 5, 1, 5, 3, 5, 488, 8, 5, 3,
		5, 490, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 3, 7, 498, 8, 7, 1, 8,
		1, 8, 1, 8, 1, 8, 5, 8, 504, 8, 8, 10, 8, 12, 8, 507, 9, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 3, 8, 513, 8, 8, 1, 8, 1, 8, 3, 8, 517, 8, 8, 1, 8, 1, 8, 1,
		8, 3, 8, 522, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 527, 8, 8, 1, 8, 1, 8, 3, 8,
		531, 8, 8, 1, 8, 1, 8, 3, 8, 535, 8, 8, 1, 8, 3, 8, 538, 8, 8, 1, 9, 1,
		9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 3, 11, 548, 8, 11, 1, 11,
		1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 5, 12, 557, 8, 12, 10, 12, 12,
		12, 560, 9, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 3, 13, 567, 8, 13, 1,
		14, 3, 14, 570, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		578, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 584, 8, 15, 10, 15, 12,
		15, 587, 9, 15, 1, 15, 1, 15, 1, 16, 1, 16, 3, 16, 593, 8, 16, 1, 16, 1,
		16, 1, 16, 1, 17, 1, 17, 3, 17, 600, 8, 17, 1, 17, 3, 17, 603, 8, 17, 1,
		17, 3, 17, 606, 8, 17, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 20,
		1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 3, 22, 624,
		8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 629, 8, 22, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 1, 23, 3, 23, 638, 8, 23, 1, 23, 1, 23, 3, 23, 642, 8,
		23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 658, 8, 24, 1, 24, 1, 24, 3, 24, 662,
		8, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 672,
		8, 25, 1, 25, 1, 25, 3, 25, 676, 8, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1,
		27, 1, 27, 1, 27, 5, 27, 685, 8, 27, 10, 27, 12, 27, 688, 9, 27, 1, 27,
		1, 27, 1, 27, 1, 27, 5, 27, 694, 8, 27, 10, 27, 12, 27, 697, 9, 27, 3,
		27, 699, 8, 27, 1, 27, 3, 27, 702, 8, 27, 1, 28, 1, 28, 1, 28, 5, 28, 707,
		8, 28, 10, 28, 12, 28, 710, 9, 28, 1, 28, 1, 28, 1, 28, 1, 28, 5, 28, 716,
		8, 28, 10, 28, 12, 28, 719, 9, 28, 3, 28, 721, 8, 28, 1, 28, 3, 28, 724,
		8, 28, 1, 29, 1, 29, 1, 29, 1, 29, 5, 29, 730, 8, 29, 10, 29, 12, 29, 733,
		9, 29, 3, 29, 735, 8, 29, 1, 29, 1, 29, 1, 30, 1, 30, 3, 30, 741, 8, 30,
		1, 30, 3, 30, 744, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 755, 8, 30, 1, 31, 1, 31, 4, 31, 759, 8, 31, 11,
		31, 12, 31, 760, 1, 31, 3, 31, 764, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32,
		3, 32, 770, 8, 32, 1, 32, 1, 32, 1, 33, 3, 33, 775, 8, 33, 1, 33, 1, 33,
		3, 33, 779, 8, 33, 1, 33, 1, 33, 3, 33, 783, 8, 33, 1, 33, 1, 33, 3, 33,
		787, 8, 33, 3, 33, 789, 8, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 3, 35, 800, 8, 35, 1, 35, 1, 35, 3, 35, 804, 8, 35,
		3, 35, 806, 8, 35, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1,
		38, 3, 38, 816, 8, 38, 1, 38, 3, 38, 819, 8, 38, 1, 39, 1, 39, 1, 39, 1,
		39, 5, 39, 825, 8, 39, 10, 39, 12, 39, 828, 9, 39, 1, 39, 1, 39, 1, 40,
		1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 840, 8, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 848, 8, 42, 10, 42, 12, 42,
		851, 9, 42, 1, 43, 1, 43, 3, 43, 855, 8, 43, 1, 44, 1, 44, 1, 44, 1, 44,
		3, 44, 861, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 869,
		8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 876, 8, 44, 10, 44, 12,
		44, 879, 9, 44, 1, 44, 1, 44, 1, 44, 3, 44, 884, 8, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 3, 44, 890, 8, 44, 1, 44, 1, 44, 3, 44, 894, 8, 44, 1, 44, 1,
		44, 1, 44, 3, 44, 899, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 904, 8, 44, 1,
		45, 1, 45, 1, 45, 1, 45, 3, 45, 910, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 5, 45, 924, 8,
		45, 10, 45, 12, 45, 927, 9, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 4, 46, 937, 8, 46, 11, 46, 12, 46, 938, 1, 46, 1, 46, 3,
		46, 943, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 4, 46, 949, 8, 46, 11, 46,
		12, 46, 950, 1, 46, 1, 46, 3, 46, 955, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5,
		46, 971, 8, 46, 10, 46, 12, 46, 974, 9, 46, 3, 46, 976, 8, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46,
		989, 8, 46, 10, 46, 12, 46, 992, 9, 46, 3, 46, 994, 8, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 1007,
		8, 46, 10, 46, 12, 46, 1010, 9, 46, 3, 46, 1012, 8, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 1025,
		8, 46, 10, 46, 12, 46, 1028, 9, 46, 1, 46, 1, 46, 5, 46, 1032, 8, 46, 10,
		46, 12, 46, 1035, 9, 46, 3, 46, 1037, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1050, 8, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 5, 46, 1060, 8, 46,
		10, 46, 12, 46, 1063, 9, 46, 1, 47, 1, 47, 3, 47, 1067, 8, 47, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51,
		1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1,
		51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 5, 51, 1098, 8, 51, 10, 51,
		12, 51, 1101, 9, 51, 3, 51, 1103, 8, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1,
		51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 5, 51, 1118,
		8, 51, 10, 51, 12, 51, 1121, 9, 51, 1, 51, 1, 51, 3, 51, 1125, 8, 51, 3,
		51, 1127, 8, 51, 1, 51, 1, 51, 5, 51, 1131, 8, 51, 10, 51, 12, 51, 1134,
		9, 51, 1, 52, 1, 52, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1151, 8, 55, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 5, 56, 1161, 8, 56, 10, 56, 12,
		56, 1164, 9, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1170, 8, 56, 1, 57,
		1, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 60, 3, 60, 1179, 8, 60, 1, 60, 1,
		60, 3, 60, 1183, 8, 60, 1, 60, 1, 60, 3, 60, 1187, 8, 60, 1, 60, 3, 60,
		1190, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 1197, 8, 61, 1,
		62, 1, 62, 1, 62, 0, 4, 84, 90, 92, 102, 63, 0, 2, 4, 6, 8, 10, 12, 14,
		16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50,
		52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86,
		88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118,
		120, 122, 124, 0, 12, 1, 0, 96, 97, 1, 0, 133, 134, 2, 0, 81, 81, 83, 83,
		1, 0, 10, 11, 2, 0, 41, 41, 121, 121, 2, 0, 44, 48, 51, 55, 1, 0, 159,
		160, 1, 0, 161, 163, 1, 0, 153, 158, 1, 0, 35, 36, 2, 0, 8, 8, 169, 169,
		14, 0, 8, 11, 32, 32, 37, 47, 56, 56, 62, 63, 76, 77, 91, 94, 96, 96, 98,
		98, 106, 110, 114, 120, 130, 130, 133, 134, 138, 152, 1369, 0, 129, 1,
		0, 0, 0, 2, 141, 1, 0, 0, 0, 4, 146, 1, 0, 0, 0, 6, 149, 1, 0, 0, 0, 8,
		448, 1, 0, 0, 0, 10, 489, 1, 0, 0, 0, 12, 491, 1, 0, 0, 0, 14, 497, 1,
		0, 0, 0, 16, 499, 1, 0, 0, 0, 18, 539, 1, 0, 0, 0, 20, 541, 1, 0, 0, 0,
		22, 545, 1, 0, 0, 0, 24, 552, 1, 0, 0, 0, 26, 563, 1, 0, 0, 0, 28, 577,
		1, 0, 0, 0, 30, 579, 1, 0, 0, 0, 32, 592, 1, 0, 0, 0, 34, 599, 1, 0, 0,
		0, 36, 607, 1, 0, 0, 0, 38, 610, 1, 0, 0, 0, 40, 613, 1, 0, 0, 0, 42, 617,
		1, 0, 0, 0, 44, 623, 1, 0, 0, 0, 46, 630, 1, 0, 0, 0, 48, 645, 1, 0, 0,
		0, 50, 665, 1, 0, 0, 0, 52, 679, 1, 0, 0, 0, 54, 701, 1, 0, 0, 0, 56, 723,
		1, 0, 0, 0, 58, 725, 1, 0, 0, 0, 60, 754, 1, 0, 0, 0, 62, 763, 1, 0, 0,
		0, 64, 765, 1, 0, 0, 0, 66, 788, 1, 0, 0, 0, 68, 790, 1, 0, 0, 0, 70, 805,
		1, 0, 0, 0, 72, 807, 1, 0, 0, 0, 74, 810, 1, 0, 0, 0, 76, 813, 1, 0, 0,
		0, 78, 820, 1, 0, 0, 0, 80, 831, 1, 0, 0, 0, 82, 833, 1, 0, 0, 0, 84, 839,
		1, 0, 0, 0, 86, 852, 1, 0, 0, 0, 88, 903, 1, 0, 0, 0, 90, 909, 1, 0, 0,
		0, 92, 1049, 1, 0, 0, 0, 94, 1066, 1, 0, 0, 0, 96, 1068, 1, 0, 0, 0, 98,
		1072, 1, 0, 0, 0, 100, 1074, 1, 0, 0, 0, 102, 1126, 1, 0, 0, 0, 104, 1135,
		1, 0, 0, 0, 106, 1137, 1, 0, 0, 0, 108, 1139, 1, 0, 0, 0, 110, 1150, 1,
		0, 0, 0, 112, 1169, 1, 0, 0, 0, 114, 1171, 1, 0, 0, 0, 116, 1173, 1, 0,
		0, 0, 118, 1175, 1, 0, 0, 0, 120, 1189, 1, 0, 0, 0, 122, 1196, 1, 0, 0,
		0, 124, 1198, 1, 0, 0, 0, 126, 128, 3, 4, 2, 0, 127, 126, 1, 0, 0, 0, 128,
		131, 1, 0, 0, 0, 129, 127, 1, 0, 0, 0, 129, 130, 1, 0, 0, 0, 130, 132,
		1, 0, 0, 0, 131, 129, 1, 0, 0, 0, 132, 133, 5, 0, 0, 1, 133, 1, 1, 0, 0,
		0, 134, 142, 3, 4, 2, 0, 135, 136, 3, 10, 5, 0, 136, 137, 5, 1, 0, 0, 137,
		142, 1, 0, 0, 0, 138, 139, 3, 12, 6, 0, 139, 140, 5, 1, 0, 0, 140, 142,
		1, 0, 0, 0, 141, 134, 1, 0, 0, 0, 141, 135, 1, 0, 0, 0, 141, 138, 1, 0,
		0, 0, 142, 144, 1, 0, 0, 0, 143, 145, 5, 0, 0, 1, 144, 143, 1, 0, 0, 0,
		144, 145, 1, 0, 0, 0, 145, 3, 1, 0, 0, 0, 146, 147, 3, 8, 4, 0, 147, 148,
		5, 1, 0, 0, 148, 5, 1, 0, 0, 0, 149, 150, 3, 82, 41, 0, 150, 151, 5, 0,
		0, 1, 151, 7, 1, 0, 0, 0, 152, 449, 3, 16, 8, 0, 153, 154, 7, 0, 0, 0,
		154, 449, 5, 124, 0, 0, 155, 157, 7, 0, 0, 0, 156, 158, 5, 15, 0, 0, 157,
		156, 1, 0, 0, 0, 157, 158, 1, 0, 0, 0, 158, 159, 1, 0, 0, 0, 159, 161,
		5, 99, 0, 0, 160, 162, 5, 89, 0, 0, 161, 160, 1, 0, 0, 0, 161, 162, 1,
		0, 0, 0, 162, 449, 1, 0, 0, 0, 163, 164, 7, 0, 0, 0, 164, 166, 5, 84, 0,
		0, 165, 167, 5, 89, 0, 0, 166, 165, 1, 0, 0, 0, 166, 167, 1, 0, 0, 0, 167,
		449, 1, 0, 0, 0, 168, 169, 7, 0, 0, 0, 169, 171, 5, 98, 0, 0, 170, 172,
		5, 89, 0, 0, 171, 170, 1, 0, 0, 0, 171, 172, 1, 0, 0, 0, 172, 449, 1, 0,
		0, 0, 173, 174, 7, 0, 0, 0, 174, 449, 5, 109, 0, 0, 175, 177, 7, 0, 0,
		0, 176, 178, 7, 1, 0, 0, 177, 176, 1, 0, 0, 0, 177, 178, 1, 0, 0, 0, 178,
		179, 1, 0, 0, 0, 179, 449, 5, 132, 0, 0, 180, 181, 7, 0, 0, 0, 181, 182,
		5, 131, 0, 0, 182, 449, 5, 144, 0, 0, 183, 184, 7, 0, 0, 0, 184, 449, 5,
		94, 0, 0, 185, 186, 7, 0, 0, 0, 186, 449, 5, 143, 0, 0, 187, 188, 5, 88,
		0, 0, 188, 190, 3, 118, 59, 0, 189, 191, 5, 89, 0, 0, 190, 189, 1, 0, 0,
		0, 190, 191, 1, 0, 0, 0, 191, 449, 1, 0, 0, 0, 192, 193, 5, 88, 0, 0, 193,
		195, 5, 84, 0, 0, 194, 196, 5, 89, 0, 0, 195, 194, 1, 0, 0, 0, 195, 196,
		1, 0, 0, 0, 196, 449, 1, 0, 0, 0, 197, 198, 5, 88, 0, 0, 198, 199, 5, 110,
		0, 0, 199, 449, 3, 110, 55, 0, 200, 201, 5, 88, 0, 0, 201, 202, 5, 131,
		0, 0, 202, 449, 3, 110, 55, 0, 203, 204, 5, 90, 0, 0, 204, 205, 3, 14,
		7, 0, 205, 206, 3, 34, 17, 0, 206, 449, 1, 0, 0, 0, 207, 208, 7, 0, 0,
		0, 208, 210, 5, 101, 0, 0, 209, 211, 5, 89, 0, 0, 210, 209, 1, 0, 0, 0,
		210, 211, 1, 0, 0, 0, 211, 449, 1, 0, 0, 0, 212, 213, 5, 102, 0, 0, 213,
		449, 3, 110, 55, 0, 214, 215, 5, 102, 0, 0, 215, 449, 5, 15, 0, 0, 216,
		217, 5, 103, 0, 0, 217, 449, 3, 110, 55, 0, 218, 219, 5, 103, 0, 0, 219,
		449, 5, 15, 0, 0, 220, 221, 5, 104, 0, 0, 221, 449, 3, 110, 55, 0, 222,
		223, 5, 104, 0, 0, 223, 449, 5, 15, 0, 0, 224, 225, 5, 116, 0, 0, 225,
		226, 5, 168, 0, 0, 226, 227, 5, 153, 0, 0, 227, 449, 5, 168, 0, 0, 228,
		229, 5, 142, 0, 0, 229, 230, 5, 147, 0, 0, 230, 231, 5, 168, 0, 0, 231,
		232, 5, 153, 0, 0, 232, 449, 5, 168, 0, 0, 233, 234, 5, 126, 0, 0, 234,
		449, 5, 168, 0, 0, 235, 236, 5, 117, 0, 0, 236, 237, 3, 114, 57, 0, 237,
		238, 5, 153, 0, 0, 238, 239, 3, 116, 58, 0, 239, 449, 1, 0, 0, 0, 240,
		241, 5, 118, 0, 0, 241, 449, 3, 114, 57, 0, 242, 245, 5, 80, 0, 0, 243,
		244, 5, 25, 0, 0, 244, 246, 5, 139, 0, 0, 245, 243, 1, 0, 0, 0, 245, 246,
		1, 0, 0, 0, 246, 248, 1, 0, 0, 0, 247, 249, 5, 134, 0, 0, 248, 247, 1,
		0, 0, 0, 248, 249, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 254, 5, 83, 0,
		0, 251, 252, 5, 152, 0, 0, 252, 253, 5, 28, 0, 0, 253, 255, 5, 29, 0, 0,
		254, 251, 1, 0, 0, 0, 254, 255, 1, 0, 0, 0, 255, 256, 1, 0, 0, 0, 256,
		258, 3, 118, 59, 0, 257, 259, 3, 24, 12, 0, 258, 257, 1, 0, 0, 0, 258,
		259, 1, 0, 0, 0, 259, 262, 1, 0, 0, 0, 260, 261, 5, 78, 0, 0, 261, 263,
		3, 30, 15, 0, 262, 260, 1, 0, 0, 0, 262, 263, 1, 0, 0, 0, 263, 449, 1,
		0, 0, 0, 264, 267, 5, 80, 0, 0, 265, 266, 5, 25, 0, 0, 266, 268, 5, 139,
		0, 0, 267, 265, 1, 0, 0, 0, 267, 268, 1, 0, 0, 0, 268, 269, 1, 0, 0, 0,
		269, 273, 5, 83, 0, 0, 270, 271, 5, 152, 0, 0, 271, 272, 5, 28, 0, 0, 272,
		274, 5, 29, 0, 0, 273, 270, 1, 0, 0, 0, 273, 274, 1, 0, 0, 0, 274, 275,
		1, 0, 0, 0, 275, 278, 3, 118, 59, 0, 276, 277, 5, 78, 0, 0, 277, 279, 3,
		30, 15, 0, 278, 276, 1, 0, 0, 0, 278, 279, 1, 0, 0, 0, 279, 280, 1, 0,
		0, 0, 280, 281, 5, 14, 0, 0, 281, 282, 3, 16, 8, 0, 282, 449, 1, 0, 0,
		0, 283, 286, 5, 80, 0, 0, 284, 285, 5, 25, 0, 0, 285, 287, 5, 139, 0, 0,
		286, 284, 1, 0, 0, 0, 286, 287, 1, 0, 0, 0, 287, 289, 1, 0, 0, 0, 288,
		290, 5, 134, 0, 0, 289, 288, 1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 291,
		1, 0, 0, 0, 291, 295, 5, 81, 0, 0, 292, 293, 5, 152, 0, 0, 293, 294, 5,
		28, 0, 0, 294, 296, 5, 29, 0, 0, 295, 292, 1, 0, 0, 0, 295, 296, 1, 0,
		0, 0, 296, 297, 1, 0, 0, 0, 297, 299, 3, 118, 59, 0, 298, 300, 3, 24, 12,
		0, 299, 298, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 303, 1, 0, 0, 0, 301,
		302, 5, 78, 0, 0, 302, 304, 3, 30, 15, 0, 303, 301, 1, 0, 0, 0, 303, 304,
		1, 0, 0, 0, 304, 449, 1, 0, 0, 0, 305, 308, 5, 80, 0, 0, 306, 307, 5, 25,
		0, 0, 307, 309, 5, 139, 0, 0, 308, 306, 1, 0, 0, 0, 308, 309, 1, 0, 0,
		0, 309, 310, 1, 0, 0, 0, 310, 314, 5, 81, 0, 0, 311, 312, 5, 152, 0, 0,
		312, 313, 5, 28, 0, 0, 313, 315, 5, 29, 0, 0, 314, 311, 1, 0, 0, 0, 314,
		315, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316, 319, 3, 118, 59, 0, 317, 318,
		5, 78, 0, 0, 318, 320, 3, 30, 15, 0, 319, 317, 1, 0, 0, 0, 319, 320, 1,
		0, 0, 0, 320, 321, 1, 0, 0, 0, 321, 322, 5, 14, 0, 0, 322, 323, 3, 16,
		8, 0, 323, 449, 1, 0, 0, 0, 324, 325, 5, 80, 0, 0, 325, 326, 7, 1, 0, 0,
		326, 330, 5, 131, 0, 0, 327, 328, 5, 152, 0, 0, 328, 329, 5, 28, 0, 0,
		329, 331, 5, 29, 0, 0, 330, 327, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331,
		332, 1, 0, 0, 0, 332, 333, 3, 110, 55, 0, 333, 334, 5, 78, 0, 0, 334, 335,
		3, 30, 15, 0, 335, 449, 1, 0, 0, 0, 336, 337, 5, 85, 0, 0, 337, 338, 5,
		87, 0, 0, 338, 341, 3, 118, 59, 0, 339, 340, 5, 78, 0, 0, 340, 342, 3,
		30, 15, 0, 341, 339, 1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 343, 1, 0,
		0, 0, 343, 344, 3, 16, 8, 0, 344, 449, 1, 0, 0, 0, 345, 346, 5, 85, 0,
		0, 346, 347, 5, 87, 0, 0, 347, 349, 3, 118, 59, 0, 348, 350, 3, 78, 39,
		0, 349, 348, 1, 0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351,
		352, 5, 79, 0, 0, 352, 353, 3, 58, 29, 0, 353, 449, 1, 0, 0, 0, 354, 355,
		5, 111, 0, 0, 355, 358, 5, 83, 0, 0, 356, 357, 5, 152, 0, 0, 357, 359,
		5, 29, 0, 0, 358, 356, 1, 0, 0, 0, 358, 359, 1, 0, 0, 0, 359, 360, 1, 0,
		0, 0, 360, 363, 3, 118, 59, 0, 361, 362, 5, 86, 0, 0, 362, 364, 5, 82,
		0, 0, 363, 361, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 449, 1, 0, 0, 0,
		365, 366, 5, 111, 0, 0, 366, 369, 5, 81, 0, 0, 367, 368, 5, 152, 0, 0,
		368, 370, 5, 29, 0, 0, 369, 367, 1, 0, 0, 0, 369, 370, 1, 0, 0, 0, 370,
		371, 1, 0, 0, 0, 371, 374, 3, 118, 59, 0, 372, 373, 5, 86, 0, 0, 373, 375,
		5, 82, 0, 0, 374, 372, 1, 0, 0, 0, 374, 375, 1, 0, 0, 0, 375, 449, 1, 0,
		0, 0, 376, 377, 5, 111, 0, 0, 377, 380, 5, 131, 0, 0, 378, 379, 5, 152,
		0, 0, 379, 381, 5, 29, 0, 0, 380, 378, 1, 0, 0, 0, 380, 381, 1, 0, 0, 0,
		381, 382, 1, 0, 0, 0, 382, 449, 3, 110, 55, 0, 383, 386, 5, 91, 0, 0, 384,
		387, 3, 8, 4, 0, 385, 387, 3, 110, 55, 0, 386, 384, 1, 0, 0, 0, 386, 385,
		1, 0, 0, 0, 387, 449, 1, 0, 0, 0, 388, 389, 5, 80, 0, 0, 389, 393, 5, 93,
		0, 0, 390, 391, 5, 152, 0, 0, 391, 392, 5, 28, 0, 0, 392, 394, 5, 29, 0,
		0, 393, 390, 1, 0, 0, 0, 393, 394, 1, 0, 0, 0, 394, 395, 1, 0, 0, 0, 395,
		396, 3, 110, 55, 0, 396, 397, 5, 14, 0, 0, 397, 398, 3, 102, 51, 0, 398,
		449, 1, 0, 0, 0, 399, 400, 5, 111, 0, 0, 400, 403, 5, 93, 0, 0, 401, 402,
		5, 152, 0, 0, 402, 404, 5, 29, 0, 0, 403, 401, 1, 0, 0, 0, 403, 404, 1,
		0, 0, 0, 404, 405, 1, 0, 0, 0, 405, 449, 3, 110, 55, 0, 406, 407, 5, 142,
		0, 0, 407, 408, 7, 2, 0, 0, 408, 409, 3, 118, 59, 0, 409, 414, 3, 22, 11,
		0, 410, 411, 5, 2, 0, 0, 411, 413, 3, 22, 11, 0, 412, 410, 1, 0, 0, 0,
		413, 416, 1, 0, 0, 0, 414, 412, 1, 0, 0, 0, 414, 415, 1, 0, 0, 0, 415,
		449, 1, 0, 0, 0, 416, 414, 1, 0, 0, 0, 417, 420, 5, 140, 0, 0, 418, 419,
		5, 28, 0, 0, 419, 421, 5, 29, 0, 0, 420, 418, 1, 0, 0, 0, 420, 421, 1,
		0, 0, 0, 421, 422, 1, 0, 0, 0, 422, 423, 5, 82, 0, 0, 423, 426, 3, 14,
		7, 0, 424, 425, 5, 78, 0, 0, 425, 427, 3, 30, 15, 0, 426, 424, 1, 0, 0,
		0, 426, 427, 1, 0, 0, 0, 427, 429, 1, 0, 0, 0, 428, 430, 3, 20, 10, 0,
		429, 428, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0, 430, 449, 1, 0, 0, 0, 431,
		434, 5, 140, 0, 0, 432, 433, 5, 28, 0, 0, 433, 435, 5, 29, 0, 0, 434, 432,
		1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 439, 5, 149,
		0, 0, 437, 438, 5, 150, 0, 0, 438, 440, 3, 14, 7, 0, 439, 437, 1, 0, 0,
		0, 439, 440, 1, 0, 0, 0, 440, 443, 1, 0, 0, 0, 441, 442, 5, 151, 0, 0,
		442, 444, 3, 122, 61, 0, 443, 441, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444,
		446, 1, 0, 0, 0, 445, 447, 3, 20, 10, 0, 446, 445, 1, 0, 0, 0, 446, 447,
		1, 0, 0, 0, 447, 449, 1, 0, 0, 0, 448, 152, 1, 0, 0, 0, 448, 153, 1, 0,
		0, 0, 448, 155, 1, 0, 0, 0, 448, 163, 1, 0, 0, 0, 448, 168, 1, 0, 0, 0,
		448, 173, 1, 0, 0, 0, 448, 175, 1, 0, 0, 0, 448, 180, 1, 0, 0, 0, 448,
		183, 1, 0, 0, 0, 448, 185, 1, 0, 0, 0, 448, 187, 1, 0, 0, 0, 448, 192,
		1, 0, 0, 0, 448, 197, 1, 0, 0, 0, 448, 200, 1, 0, 0, 0, 448, 203, 1, 0,
		0, 0, 448, 207, 1, 0, 0, 0, 448, 212, 1, 0, 0, 0, 448, 214, 1, 0, 0, 0,
		448, 216, 1, 0, 0, 0, 448, 218, 1, 0, 0, 0, 448, 220, 1, 0, 0, 0, 448,
		222, 1, 0, 0, 0, 448, 224, 1, 0, 0, 0, 448, 228, 1, 0, 0, 0, 448, 233,
		1, 0, 0, 0, 448, 235, 1, 0, 0, 0, 448, 240, 1, 0, 0, 0, 448, 242, 1, 0,
		0, 0, 448, 264, 1, 0, 0, 0, 448, 283, 1, 0, 0, 0, 448, 305, 1, 0, 0, 0,
		448, 324, 1, 0, 0, 0, 448, 336, 1, 0, 0, 0, 448, 345, 1, 0, 0, 0, 448,
		354, 1, 0, 0, 0, 448, 365, 1, 0, 0, 0, 448, 376, 1, 0, 0, 0, 448, 383,
		1, 0, 0, 0, 448, 388, 1, 0, 0, 0, 448, 399, 1, 0, 0, 0, 448, 406, 1, 0,
		0, 0, 448, 417, 1, 0, 0, 0, 448, 431, 1, 0, 0, 0, 449, 9, 1, 0, 0, 0, 450,
		451, 5, 140, 0, 0, 451, 452, 5, 79, 0, 0, 452, 454, 3, 118, 59, 0, 453,
		455, 3, 78, 39, 0, 454, 453, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 456,
		1, 0, 0, 0, 456, 457, 5, 79, 0, 0, 457, 458, 3, 58, 29, 0, 458, 490, 1,
		0, 0, 0, 459, 460, 5, 140, 0, 0, 460, 461, 5, 34, 0, 0, 461, 462, 5, 79,
		0, 0, 462, 464, 3, 118, 59, 0, 463, 465, 3, 78, 39, 0, 464, 463, 1, 0,
		0, 0, 464, 465, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 467, 5, 130, 0,
		0, 467, 468, 3, 58, 29, 0, 468, 490, 1, 0, 0, 0, 469, 470, 5, 140, 0, 0,
		470, 471, 5, 83, 0, 0, 471, 473, 3, 118, 59, 0, 472, 474, 3, 24, 12, 0,
		473, 472, 1, 0, 0, 0, 473, 474, 1, 0, 0, 0, 474, 477, 1, 0, 0, 0, 475,
		476, 5, 78, 0, 0, 476, 478, 3, 30, 15, 0, 477, 475, 1, 0, 0, 0, 477, 478,
		1, 0, 0, 0, 478, 490, 1, 0, 0, 0, 479, 480, 5, 140, 0, 0, 480, 481, 5,
		81, 0, 0, 481, 483, 3, 118, 59, 0, 482, 484, 3, 24, 12, 0, 483, 482, 1,
		0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 487, 1, 0, 0, 0, 485, 486, 5, 78, 0,
		0, 486, 488, 3, 30, 15, 0, 487, 485, 1, 0, 0, 0, 487, 488, 1, 0, 0, 0,
		488, 490, 1, 0, 0, 0, 489, 450, 1, 0, 0, 0, 489, 459, 1, 0, 0, 0, 489,
		469, 1, 0, 0, 0, 489, 479, 1, 0, 0, 0, 490, 11, 1, 0, 0, 0, 491, 492, 5,
		127, 0, 0, 492, 493, 5, 128, 0, 0, 493, 494, 5, 168, 0, 0, 494, 13, 1,
		0, 0, 0, 495, 498, 3, 110, 55, 0, 496, 498, 5, 168, 0, 0, 497, 495, 1,
		0, 0, 0, 497, 496, 1, 0, 0, 0, 498, 15, 1, 0, 0, 0, 499, 500, 5, 12, 0,
		0, 500, 505, 3, 60, 30, 0, 501, 502, 5, 2, 0, 0, 502, 504, 3, 60, 30, 0,
		503, 501, 1, 0, 0, 0, 504, 507, 1, 0, 0, 0, 505, 503, 1, 0, 0, 0, 505,
		506, 1, 0, 0, 0, 506, 508, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 508, 509,
		5, 13, 0, 0, 509, 512, 3, 62, 31, 0, 510, 511, 5, 19, 0, 0, 511, 513, 3,
		44, 22, 0, 512, 510, 1, 0, 0, 0, 512, 513, 1, 0, 0, 0, 513, 516, 1, 0,
		0, 0, 514, 515, 5, 17, 0, 0, 515, 517, 3, 84, 42, 0, 516, 514, 1, 0, 0,
		0, 516, 517, 1, 0, 0, 0, 517, 521, 1, 0, 0, 0, 518, 519, 5, 20, 0, 0, 519,
		520, 5, 21, 0, 0, 520, 522, 3, 54, 27, 0, 521, 518, 1, 0, 0, 0, 521, 522,
		1, 0, 0, 0, 522, 526, 1, 0, 0, 0, 523, 524, 5, 76, 0, 0, 524, 525, 5, 21,
		0, 0, 525, 527, 3, 56, 28, 0, 526, 523, 1, 0, 0, 0, 526, 527, 1, 0, 0,
		0, 527, 530, 1, 0, 0, 0, 528, 529, 5, 22, 0, 0, 529, 531, 3, 84, 42, 0,
		530, 528, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 534, 1, 0, 0, 0, 532,
		533, 5, 9, 0, 0, 533, 535, 3, 18, 9, 0, 534, 532, 1, 0, 0, 0, 534, 535,
		1, 0, 0, 0, 535, 537, 1, 0, 0, 0, 536, 538, 3, 38, 19, 0, 537, 536, 1,
		0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 17, 1, 0, 0, 0, 539, 540, 7, 3, 0,
		0, 540, 19, 1, 0, 0, 0, 541, 542, 5, 148, 0, 0, 542, 543, 3, 120, 60, 0,
		543, 544, 3, 52, 26, 0, 544, 21, 1, 0, 0, 0, 545, 547, 5, 141, 0, 0, 546,
		548, 5, 107, 0, 0, 547, 546, 1, 0, 0, 0, 547, 548, 1, 0, 0, 0, 548, 549,
		1, 0, 0, 0, 549, 550, 3, 110, 55, 0, 550, 551, 3, 102, 51, 0, 551, 23,
		1, 0, 0, 0, 552, 553, 5, 3, 0, 0, 553, 558, 3, 26, 13, 0, 554, 555, 5,
		2, 0, 0, 555, 557, 3, 26, 13, 0, 556, 554, 1, 0, 0, 0, 557, 560, 1, 0,
		0, 0, 558, 556, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 561, 1, 0, 0, 0,
		560, 558, 1, 0, 0, 0, 561, 562, 5, 4, 0, 0, 562, 25, 1, 0, 0, 0, 563, 564,
		3, 110, 55, 0, 564, 566, 3, 102, 51, 0, 565, 567, 3, 28, 14, 0, 566, 565,
		1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 27, 1, 0, 0, 0, 568, 570, 5, 138,
		0, 0, 569, 568, 1, 0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0,
		571, 578, 5, 130, 0, 0, 572, 578, 5, 145, 0, 0, 573, 574, 5, 146, 0, 0,
		574, 575, 5, 3, 0, 0, 575, 576, 5, 168, 0, 0, 576, 578, 5, 4, 0, 0, 577,
		569, 1, 0, 0, 0, 577, 572, 1, 0, 0, 0, 577, 573, 1, 0, 0, 0, 578, 29, 1,
		0, 0, 0, 579, 580, 5, 3, 0, 0, 580, 585, 3, 32, 16, 0, 581, 582, 5, 2,
		0, 0, 582, 584, 3, 32, 16, 0, 583, 581, 1, 0, 0, 0, 584, 587, 1, 0, 0,
		0, 585, 583, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586, 588, 1, 0, 0, 0, 587,
		585, 1, 0, 0, 0, 588, 589, 5, 4, 0, 0, 589, 31, 1, 0, 0, 0, 590, 593, 3,
		110, 55, 0, 591, 593, 5, 168, 0, 0, 592, 590, 1, 0, 0, 0, 592, 591, 1,
		0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 595, 5, 153, 0, 0, 595, 596, 3, 122,
		61, 0, 596, 33, 1, 0, 0, 0, 597, 598, 5, 13, 0, 0, 598, 600, 5, 125, 0,
		0, 599, 597, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 602, 1, 0, 0, 0, 601,
		603, 3, 36, 18, 0, 602, 601, 1, 0, 0, 0, 602, 603, 1, 0, 0, 0, 603, 605,
		1, 0, 0, 0, 604, 606, 3, 38, 19, 0, 605, 604, 1, 0, 0, 0, 605, 606, 1,
		0, 0, 0, 606, 35, 1, 0, 0, 0, 607, 608, 7, 4, 0, 0, 608, 609, 3, 120, 60,
		0, 609, 37, 1, 0, 0, 0, 610, 611, 5, 23, 0, 0, 611, 612, 3, 120, 60, 0,
		612, 39, 1, 0, 0, 0, 613, 614, 5, 61, 0, 0, 614, 615, 3, 120, 60, 0, 615,
		616, 3, 52, 26, 0, 616, 41, 1, 0, 0, 0, 617, 618, 5, 62, 0, 0, 618, 619,
		5, 63, 0, 0, 619, 620, 3, 120, 60, 0, 620, 621, 3, 52, 26, 0, 621, 43,
		1, 0, 0, 0, 622, 624, 5, 172, 0, 0, 623, 622, 1, 0, 0, 0, 623, 624, 1,
		0, 0, 0, 624, 628, 1, 0, 0, 0, 625, 629, 3, 46, 23, 0, 626, 629, 3, 48,
		24, 0, 627, 629, 3, 50, 25, 0, 628, 625, 1, 0, 0, 0, 628, 626, 1, 0, 0,
		0, 628, 627, 1, 0, 0, 0, 629, 45, 1, 0, 0, 0, 630, 631, 5, 57, 0, 0, 631,
		632, 5, 3, 0, 0, 632, 633, 5, 59, 0, 0, 633, 634, 3, 120, 60, 0, 634, 637,
		3, 52, 26, 0, 635, 636, 5, 2, 0, 0, 636, 638, 3, 40, 20, 0, 637, 635, 1,
		0, 0, 0, 637, 638, 1, 0, 0, 0, 638, 641, 1, 0, 0, 0, 639, 640, 5, 2, 0,
		0, 640, 642, 3, 42, 21, 0, 641, 639, 1, 0, 0, 0, 641, 642, 1, 0, 0, 0,
		642, 643, 1, 0, 0, 0, 643, 644, 5, 4, 0, 0, 644, 47, 1, 0, 0, 0, 645, 646,
		5, 58, 0, 0, 646, 647, 5, 3, 0, 0, 647, 648, 5, 59, 0, 0, 648, 649, 3,
		120, 60, 0, 649, 650, 3, 52, 26, 0, 650, 651, 5, 2, 0, 0, 651, 652, 5,
		60, 0, 0, 652, 653, 5, 21, 0, 0, 653, 654, 3, 120, 60, 0, 654, 657, 3,
		52, 26, 0, 655, 656, 5, 2, 0, 0, 656, 658, 3, 40, 20, 0, 657, 655, 1, 0,
		0, 0, 657, 658, 1, 0, 0, 0, 658, 661, 1, 0, 0, 0, 659, 660, 5, 2, 0, 0,
		660, 662, 3, 42, 21, 0, 661, 659, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662,
		663, 1, 0, 0, 0, 663, 664, 5, 4, 0, 0, 664, 49, 1, 0, 0, 0, 665, 666, 5,
		120, 0, 0, 666, 667, 5, 3, 0, 0, 667, 668, 3, 120, 60, 0, 668, 671, 3,
		52, 26, 0, 669, 670, 5, 2, 0, 0, 670, 672, 3, 40, 20, 0, 671, 669, 1, 0,
		0, 0, 671, 672, 1, 0, 0, 0, 672, 675, 1, 0, 0, 0, 673, 674, 5, 2, 0, 0,
		674, 676, 3, 42, 21, 0, 675, 673, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676,
		677, 1, 0, 0, 0, 677, 678, 5, 4, 0, 0, 678, 51, 1, 0, 0, 0, 679, 680, 7,
		5, 0, 0, 680, 53, 1, 0, 0, 0, 681, 686, 3, 90, 45, 0, 682, 683, 5, 2, 0,
		0, 683, 685, 3, 90, 45, 0, 684, 682, 1, 0, 0, 0, 685, 688, 1, 0, 0, 0,
		686, 684, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 702, 1, 0, 0, 0, 688,
		686, 1, 0, 0, 0, 689, 698, 5, 3, 0, 0, 690, 695, 3, 90, 45, 0, 691, 692,
		5, 2, 0, 0, 692, 694, 3, 90, 45, 0, 693, 691, 1, 0, 0, 0, 694, 697, 1,
		0, 0, 0, 695, 693, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 699, 1, 0, 0,
		0, 697, 695, 1, 0, 0, 0, 698, 690, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699,
		700, 1, 0, 0, 0, 700, 702, 5, 4, 0, 0, 701, 681, 1, 0, 0, 0, 701, 689,
		1, 0, 0, 0, 702, 55, 1, 0, 0, 0, 703, 708, 3, 90, 45, 0, 704, 705, 5, 2,
		0, 0, 705, 707, 3, 90, 45, 0, 706, 704, 1, 0, 0, 0, 707, 710, 1, 0, 0,
		0, 708, 706, 1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709, 724, 1, 0, 0, 0, 710,
		708, 1, 0, 0, 0, 711, 720, 5, 3, 0, 0, 712, 717, 3, 90, 45, 0, 713, 714,
		5, 2, 0, 0, 714, 716, 3, 90, 45, 0, 715, 713, 1, 0, 0, 0, 716, 719, 1,
		0, 0, 0, 717, 715, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 721, 1, 0, 0,
		0, 719, 717, 1, 0, 0, 0, 720, 712, 1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721,
		722, 1, 0, 0, 0, 722, 724, 5, 4, 0, 0, 723, 703, 1, 0, 0, 0, 723, 711,
		1, 0, 0, 0, 724, 57, 1, 0, 0, 0, 725, 734, 5, 3, 0, 0, 726, 731, 3, 90,
		45, 0, 727, 728, 5, 2, 0, 0, 728, 730, 3, 90, 45, 0, 729, 727, 1, 0, 0,
		0, 730, 733, 1, 0, 0, 0, 731, 729, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0, 732,
		735, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 734, 726, 1, 0, 0, 0, 734, 735,
		1, 0, 0, 0, 735, 736, 1, 0, 0, 0, 736, 737, 5, 4, 0, 0, 737, 59, 1, 0,
		0, 0, 738, 743, 3, 82, 41, 0, 739, 741, 5, 14, 0, 0, 740, 739, 1, 0, 0,
		0, 740, 741, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 744, 3, 110, 55, 0,
		743, 740, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 755, 1, 0, 0, 0, 745,
		746, 3, 92, 46, 0, 746, 747, 5, 166, 0, 0, 747, 748, 5, 161, 0, 0, 748,
		755, 1, 0, 0, 0, 749, 750, 3, 110, 55, 0, 750, 751, 5, 5, 0, 0, 751, 752,
		5, 161, 0, 0, 752, 755, 1, 0, 0, 0, 753, 755, 5, 161, 0, 0, 754, 738, 1,
		0, 0, 0, 754, 745, 1, 0, 0, 0, 754, 749, 1, 0, 0, 0, 754, 753, 1, 0, 0,
		0, 755, 61, 1, 0, 0, 0, 756, 758, 3, 76, 38, 0, 757, 759, 3, 64, 32, 0,
		758, 757, 1, 0, 0, 0, 759, 760, 1, 0, 0, 0, 760, 758, 1, 0, 0, 0, 760,
		761, 1, 0, 0, 0, 761, 764, 1, 0, 0, 0, 762, 764, 3, 76, 38, 0, 763, 756,
		1, 0, 0, 0, 763, 762, 1, 0, 0, 0, 764, 63, 1, 0, 0, 0, 765, 766, 3, 66,
		33, 0, 766, 767, 5, 69, 0, 0, 767, 769, 3, 76, 38, 0, 768, 770, 3, 68,
		34, 0, 769, 768, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 771, 1, 0, 0, 0,
		771, 772, 3, 74, 37, 0, 772, 65, 1, 0, 0, 0, 773, 775, 5, 72, 0, 0, 774,
		773, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 789, 1, 0, 0, 0, 776, 778,
		5, 70, 0, 0, 777, 779, 5, 71, 0, 0, 778, 777, 1, 0, 0, 0, 778, 779, 1,
		0, 0, 0, 779, 789, 1, 0, 0, 0, 780, 782, 5, 73, 0, 0, 781, 783, 5, 71,
		0, 0, 782, 781, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 789, 1, 0, 0, 0,
		784, 786, 5, 74, 0, 0, 785, 787, 5, 71, 0, 0, 786, 785, 1, 0, 0, 0, 786,
		787, 1, 0, 0, 0, 787, 789, 1, 0, 0, 0, 788, 774, 1, 0, 0, 0, 788, 776,
		1, 0, 0, 0, 788, 780, 1, 0, 0, 0, 788, 784, 1, 0, 0, 0, 789, 67, 1, 0,
		0, 0, 790, 791, 5, 18, 0, 0, 791, 792, 3, 70, 35, 0, 792, 69, 1, 0, 0,
		0, 793, 794, 5, 3, 0, 0, 794, 795, 3, 72, 36, 0, 795, 796, 5, 2, 0, 0,
		796, 797, 3, 72, 36, 0, 797, 799, 5, 4, 0, 0, 798, 800, 3, 42, 21, 0, 799,
		798, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 806, 1, 0, 0, 0, 801, 803,
		3, 72, 36, 0, 802, 804, 3, 42, 21, 0, 803, 802, 1, 0, 0, 0, 803, 804, 1,
		0, 0, 0, 804, 806, 1, 0, 0, 0, 805, 793, 1, 0, 0, 0, 805, 801, 1, 0, 0,
		0, 806, 71, 1, 0, 0, 0, 807, 808, 3, 120, 60, 0, 808, 809, 3, 52, 26, 0,
		809, 73, 1, 0, 0, 0, 810, 811, 5, 75, 0, 0, 811, 812, 3, 84, 42, 0, 812,
		75, 1, 0, 0, 0, 813, 818, 3, 80, 40, 0, 814, 816, 5, 14, 0, 0, 815, 814,
		1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 817, 819, 3, 118,
		59, 0, 818, 815, 1, 0, 0, 0, 818, 819, 1, 0, 0, 0, 819, 77, 1, 0, 0, 0,
		820, 821, 5, 3, 0, 0, 821, 826, 3, 110, 55, 0, 822, 823, 5, 2, 0, 0, 823,
		825, 3, 110, 55, 0, 824, 822, 1, 0, 0, 0, 825, 828, 1, 0, 0, 0, 826, 824,
		1, 0, 0, 0, 826, 827, 1, 0, 0, 0, 827, 829, 1, 0, 0, 0, 828, 826, 1, 0,
		0, 0, 829, 830, 5, 4, 0, 0, 830, 79, 1, 0, 0, 0, 831, 832, 3, 118, 59,
		0, 832, 81, 1, 0, 0, 0, 833, 834, 3, 84, 42, 0, 834, 83, 1, 0, 0, 0, 835,
		836, 6, 42, -1, 0, 836, 840, 3, 86, 43, 0, 837, 838, 5, 28, 0, 0, 838,
		840, 3, 84, 42, 3, 839, 835, 1, 0, 0, 0, 839, 837, 1, 0, 0, 0, 840, 849,
		1, 0, 0, 0, 841, 842, 10, 2, 0, 0, 842, 843, 5, 26, 0, 0, 843, 848, 3,
		84, 42, 3, 844, 845, 10, 1, 0, 0, 845, 846, 5, 25, 0, 0, 846, 848, 3, 84,
		42, 2, 847, 841, 1, 0, 0, 0, 847, 844, 1, 0, 0, 0, 848, 851, 1, 0, 0, 0,
		849, 847, 1, 0, 0, 0, 849, 850, 1, 0, 0, 0, 850, 85, 1, 0, 0, 0, 851, 849,
		1, 0, 0, 0, 852, 854, 3, 90, 45, 0, 853, 855, 3, 88, 44, 0, 854, 853, 1,
		0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 87, 1, 0, 0, 0, 856, 857, 3, 98, 49,
		0, 857, 858, 3, 90, 45, 0, 858, 904, 1, 0, 0, 0, 859, 861, 5, 28, 0, 0,
		860, 859, 1, 0, 0, 0, 860, 861, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862,
		863, 5, 30, 0, 0, 863, 864, 3, 90, 45, 0, 864, 865, 5, 26, 0, 0, 865, 866,
		3, 90, 45, 0, 866, 904, 1, 0, 0, 0, 867, 869, 5, 28, 0, 0, 868, 867, 1,
		0, 0, 0, 868, 869, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 871, 5, 27, 0,
		0, 871, 872, 5, 3, 0, 0, 872, 877, 3, 82, 41, 0, 873, 874, 5, 2, 0, 0,
		874, 876, 3, 82, 41, 0, 875, 873, 1, 0, 0, 0, 876, 879, 1, 0, 0, 0, 877,
		875, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 880, 1, 0, 0, 0, 879, 877,
		1, 0, 0, 0, 880, 881, 5, 4, 0, 0, 881, 904, 1, 0, 0, 0, 882, 884, 5, 28,
		0, 0, 883, 882, 1, 0, 0, 0, 883, 884, 1, 0, 0, 0, 884, 885, 1, 0, 0, 0,
		885, 886, 5, 31, 0, 0, 886, 889, 3, 90, 45, 0, 887, 888, 5, 32, 0, 0, 888,
		890, 5, 168, 0, 0, 889, 887, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 904,
		1, 0, 0, 0, 891, 893, 5, 33, 0, 0, 892, 894, 5, 28, 0, 0, 893, 892, 1,
		0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 904, 5, 34, 0,
		0, 896, 898, 5, 33, 0, 0, 897, 899, 5, 28, 0, 0, 898, 897, 1, 0, 0, 0,
		898, 899, 1, 0, 0, 0, 899, 900, 1, 0, 0, 0, 900, 901, 5, 16, 0, 0, 901,
		902, 5, 13, 0, 0, 902, 904, 3, 90, 45, 0, 903, 856, 1, 0, 0, 0, 903, 860,
		1, 0, 0, 0, 903, 868, 1, 0, 0, 0, 903, 883, 1, 0, 0, 0, 903, 891, 1, 0,
		0, 0, 903, 896, 1, 0, 0, 0, 904, 89, 1, 0, 0, 0, 905, 906, 6, 45, -1, 0,
		906, 910, 3, 92, 46, 0, 907, 908, 7, 6, 0, 0, 908, 910, 3, 90, 45, 4, 909,
		905, 1, 0, 0, 0, 909, 907, 1, 0, 0, 0, 910, 925, 1, 0, 0, 0, 911, 912,
		10, 3, 0, 0, 912, 913, 7, 7, 0, 0, 913, 924, 3, 90, 45, 4, 914, 915, 10,
		2, 0, 0, 915, 916, 7, 6, 0, 0, 916, 924, 3, 90, 45, 3, 917, 918, 10, 1,
		0, 0, 918, 919, 5, 164, 0, 0, 919, 924, 3, 90, 45, 2, 920, 921, 10, 5,
		0, 0, 921, 922, 5, 24, 0, 0, 922, 924, 3, 96, 48, 0, 923, 911, 1, 0, 0,
		0, 923, 914, 1, 0, 0, 0, 923, 917, 1, 0, 0, 0, 923, 920, 1, 0, 0, 0, 924,
		927, 1, 0, 0, 0, 925, 923, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 91, 1,
		0, 0, 0, 927, 925, 1, 0, 0, 0, 928, 929, 6, 46, -1, 0, 929, 1050, 3, 122,
		61, 0, 930, 931, 3, 110, 55, 0, 931, 932, 5, 168, 0, 0, 932, 1050, 1, 0,
		0, 0, 933, 934, 5, 64, 0, 0, 934, 936, 3, 90, 45, 0, 935, 937, 3, 108,
		54, 0, 936, 935, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 936, 1, 0, 0, 0,
		938, 939, 1, 0, 0, 0, 939, 942, 1, 0, 0, 0, 940, 941, 5, 67, 0, 0, 941,
		943, 3, 82, 41, 0, 942, 940, 1, 0, 0, 0, 942, 943, 1, 0, 0, 0, 943, 944,
		1, 0, 0, 0, 944, 945, 5, 68, 0, 0, 945, 1050, 1, 0, 0, 0, 946, 948, 5,
		64, 0, 0, 947, 949, 3, 108, 54, 0, 948, 947, 1, 0, 0, 0, 949, 950, 1, 0,
		0, 0, 950, 948, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 954, 1, 0, 0, 0,
		952, 953, 5, 67, 0, 0, 953, 955, 3, 82, 41, 0, 954, 952, 1, 0, 0, 0, 954,
		955, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 957, 5, 68, 0, 0, 957, 1050,
		1, 0, 0, 0, 958, 959, 5, 95, 0, 0, 959, 960, 5, 3, 0, 0, 960, 961, 3, 82,
		41, 0, 961, 962, 5, 14, 0, 0, 962, 963, 3, 102, 51, 0, 963, 964, 5, 4,
		0, 0, 964, 1050, 1, 0, 0, 0, 965, 966, 5, 114, 0, 0, 966, 975, 5, 6, 0,
		0, 967, 972, 3, 82, 41, 0, 968, 969, 5, 2, 0, 0, 969, 971, 3, 82, 41, 0,
		970, 968, 1, 0, 0, 0, 971, 974, 1, 0, 0, 0, 972, 970, 1, 0, 0, 0, 972,
		973, 1, 0, 0, 0, 973, 976, 1, 0, 0, 0, 974, 972, 1, 0, 0, 0, 975, 967,
		1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 976, 977, 1, 0, 0, 0, 977, 1050, 5, 7,
		0, 0, 978, 979, 5, 115, 0, 0, 979, 993, 5, 3, 0, 0, 980, 981, 3, 82, 41,
		0, 981, 982, 5, 165, 0, 0, 982, 990, 3, 82, 41, 0, 983, 984, 5, 2, 0, 0,
		984, 985, 3, 82, 41, 0, 985, 986, 5, 165, 0, 0, 986, 987, 3, 82, 41, 0,
		987, 989, 1, 0, 0, 0, 988, 983, 1, 0, 0, 0, 989, 992, 1, 0, 0, 0, 990,
		988, 1, 0, 0, 0, 990, 991, 1, 0, 0, 0, 991, 994, 1, 0, 0, 0, 992, 990,
		1, 0, 0, 0, 993, 980, 1, 0, 0, 0, 993, 994, 1, 0, 0, 0, 994, 995, 1, 0,
		0, 0, 995, 1050, 5, 4, 0, 0, 996, 997, 5, 77, 0, 0, 997, 1011, 5, 3, 0,
		0, 998, 999, 3, 110, 55, 0, 999, 1000, 5, 165, 0, 0, 1000, 1008, 3, 82,
		41, 0, 1001, 1002, 5, 2, 0, 0, 1002, 1003, 3, 110, 55, 0, 1003, 1004, 5,
		165, 0, 0, 1004, 1005, 3, 82, 41, 0, 1005, 1007, 1, 0, 0, 0, 1006, 1001,
		1, 0, 0, 0, 1007, 1010, 1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1008, 1009,
		1, 0, 0, 0, 1009, 1012, 1, 0, 0, 0, 1010, 1008, 1, 0, 0, 0, 1011, 998,
		1, 0, 0, 0, 1011, 1012, 1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1050,
		5, 4, 0, 0, 1014, 1015, 3, 110, 55, 0, 1015, 1016, 5, 3, 0, 0, 1016, 1017,
		5, 161, 0, 0, 1017, 1018, 5, 4, 0, 0, 1018, 1050, 1, 0, 0, 0, 1019, 1020,
		3, 110, 55, 0, 1020, 1036, 5, 3, 0, 0, 1021, 1026, 3, 94, 47, 0, 1022,
		1023, 5, 2, 0, 0, 1023, 1025, 3, 94, 47, 0, 1024, 1022, 1, 0, 0, 0, 1025,
		1028, 1, 0, 0, 0, 1026, 1024, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027,
		1033, 1, 0, 0, 0, 1028, 1026, 1, 0, 0, 0, 1029, 1030, 5, 2, 0, 0, 1030,
		1032, 3, 112, 56, 0, 1031, 1029, 1, 0, 0, 0, 1032, 1035, 1, 0, 0, 0, 1033,
		1031, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1037, 1, 0, 0, 0, 1035,
		1033, 1, 0, 0, 0, 1036, 1021, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037,
		1038, 1, 0, 0, 0, 1038, 1039, 5, 4, 0, 0, 1039, 1050, 1, 0, 0, 0, 1040,
		1050, 3, 110, 55, 0, 1041, 1042, 3, 110, 55, 0, 1042, 1043, 5, 5, 0, 0,
		1043, 1044, 3, 110, 55, 0, 1044, 1050, 1, 0, 0, 0, 1045, 1046, 5, 3, 0,
		0, 1046, 1047, 3, 82, 41, 0, 1047, 1048, 5, 4, 0, 0, 1048, 1050, 1, 0,
		0, 0, 1049, 928, 1, 0, 0, 0, 1049, 930, 1, 0, 0, 0, 1049, 933, 1, 0, 0,
		0, 1049, 946, 1, 0, 0, 0, 1049, 958, 1, 0, 0, 0, 1049, 965, 1, 0, 0, 0,
		1049, 978, 1, 0, 0, 0, 1049, 996, 1, 0, 0, 0, 1049, 1014, 1, 0, 0, 0, 1049,
		1019, 1, 0, 0, 0, 1049, 1040, 1, 0, 0, 0, 1049, 1041, 1, 0, 0, 0, 1049,
		1045, 1, 0, 0, 0, 1050, 1061, 1, 0, 0, 0, 1051, 1052, 10, 5, 0, 0, 1052,
		1053, 5, 6, 0, 0, 1053, 1054, 3, 90, 45, 0, 1054, 1055, 5, 7, 0, 0, 1055,
		1060, 1, 0, 0, 0, 1056, 1057, 10, 2, 0, 0, 1057, 1058, 5, 166, 0, 0, 1058,
		1060, 3, 110, 55, 0, 1059, 1051, 1, 0, 0, 0, 1059, 1056, 1, 0, 0, 0, 1060,
		1063, 1, 0, 0, 0, 1061, 1059, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062,
		93, 1, 0, 0, 0, 1063, 1061, 1, 0, 0, 0, 1064, 1067, 3, 82, 41, 0, 1065,
		1067, 3, 52, 26, 0, 1066, 1064, 1, 0, 0, 0, 1066, 1065, 1, 0, 0, 0, 1067,
		95, 1, 0, 0, 0, 1068, 1069, 5, 39, 0, 0, 1069, 1070, 5, 56, 0, 0, 1070,
		1071, 5, 168, 0, 0, 1071, 97, 1, 0, 0, 0, 1072, 1073, 7, 8, 0, 0, 1073,
		99, 1, 0, 0, 0, 1074, 1075, 7, 9, 0, 0, 1075, 101, 1, 0, 0, 0, 1076, 1077,
		6, 51, -1, 0, 1077, 1078, 5, 114, 0, 0, 1078, 1079, 5, 155, 0, 0, 1079,
		1080, 3, 102, 51, 0, 1080, 1081, 5, 157, 0, 0, 1081, 1127, 1, 0, 0, 0,
		1082, 1083, 5, 115, 0, 0, 1083, 1084, 5, 155, 0, 0, 1084, 1085, 3, 102,
		51, 0, 1085, 1086, 5, 2, 0, 0, 1086, 1087, 3, 102, 51, 0, 1087, 1088, 5,
		157, 0, 0, 1088, 1127, 1, 0, 0, 0, 1089, 1090, 5, 77, 0, 0, 1090, 1102,
		5, 155, 0, 0, 1091, 1092, 3, 110, 55, 0, 1092, 1099, 3, 102, 51, 0, 1093,
		1094, 5, 2, 0, 0, 1094, 1095, 3, 110, 55, 0, 1095, 1096, 3, 102, 51, 0,
		1096, 1098, 1, 0, 0, 0, 1097, 1093, 1, 0, 0, 0, 1098, 1101, 1, 0, 0, 0,
		1099, 1097, 1, 0, 0, 0, 1099, 1100, 1, 0, 0, 0, 1100, 1103, 1, 0, 0, 0,
		1101, 1099, 1, 0, 0, 0, 1102, 1091, 1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0,
		1103, 1104, 1, 0, 0, 0, 1104, 1127, 5, 157, 0, 0, 1105, 1106, 5, 129, 0,
		0, 1106, 1107, 5, 3, 0, 0, 1107, 1108, 3, 120, 60, 0, 1108, 1109, 5, 2,
		0, 0, 1109, 1110, 3, 120, 60, 0, 1110, 1111, 5, 4, 0, 0, 1111, 1127, 1,
		0, 0, 0, 1112, 1124, 3, 106, 53, 0, 1113, 1114, 5, 3, 0, 0, 1114, 1119,
		3, 104, 52, 0, 1115, 1116, 5, 2, 0, 0, 1116, 1118, 3, 104, 52, 0, 1117,
		1115, 1, 0, 0, 0, 1118, 1121, 1, 0, 0, 0, 1119, 1117, 1, 0, 0, 0, 1119,
		1120, 1, 0, 0, 0, 1120, 1122, 1, 0, 0, 0, 1121, 1119, 1, 0, 0, 0, 1122,
		1123, 5, 4, 0, 0, 1123, 1125, 1, 0, 0, 0, 1124, 1113, 1, 0, 0, 0, 1124,
		1125, 1, 0, 0, 0, 1125, 1127, 1, 0, 0, 0, 1126, 1076, 1, 0, 0, 0, 1126,
		1082, 1, 0, 0, 0, 1126, 1089, 1, 0, 0, 0, 1126, 1105, 1, 0, 0, 0, 1126,
		1112, 1, 0, 0, 0, 1127, 1132, 1, 0, 0, 0, 1128, 1129, 10, 6, 0, 0, 1129,
		1131, 5, 114, 0, 0, 1130, 1128, 1, 0, 0, 0, 1131, 1134, 1, 0, 0, 0, 1132,
		1130, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 103, 1, 0, 0, 0, 1134,
		1132, 1, 0, 0, 0, 1135, 1136, 7, 10, 0, 0, 1136, 105, 1, 0, 0, 0, 1137,
		1138, 3, 110, 55, 0, 1138, 107, 1, 0, 0, 0, 1139, 1140, 5, 65, 0, 0, 1140,
		1141, 3, 82, 41, 0, 1141, 1142, 5, 66, 0, 0, 1142, 1143, 3, 82, 41, 0,
		1143, 109, 1, 0, 0, 0, 1144, 1151, 5, 176, 0, 0, 1145, 1151, 5, 172, 0,
		0, 1146, 1151, 5, 174, 0, 0, 1147, 1151, 3, 124, 62, 0, 1148, 1151, 5,
		175, 0, 0, 1149, 1151, 5, 173, 0, 0, 1150, 1144, 1, 0, 0, 0, 1150, 1145,
		1, 0, 0, 0, 1150, 1146, 1, 0, 0, 0, 1150, 1147, 1, 0, 0, 0, 1150, 1148,
		1, 0, 0, 0, 1150, 1149, 1, 0, 0, 0, 1151, 111, 1, 0, 0, 0, 1152, 1153,
		3, 110, 55, 0, 1153, 1154, 5, 167, 0, 0, 1154, 1155, 3, 82, 41, 0, 1155,
		1170, 1, 0, 0, 0, 1156, 1157, 5, 3, 0, 0, 1157, 1162, 3, 110, 55, 0, 1158,
		1159, 5, 2, 0, 0, 1159, 1161, 3, 110, 55, 0, 1160, 1158, 1, 0, 0, 0, 1161,
		1164, 1, 0, 0, 0, 1162, 1160, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163,
		1165, 1, 0, 0, 0, 1164, 1162, 1, 0, 0, 0, 1165, 1166, 5, 4, 0, 0, 1166,
		1167, 5, 167, 0, 0, 1167, 1168, 3, 82, 41, 0, 1168, 1170, 1, 0, 0, 0, 1169,
		1152, 1, 0, 0, 0, 1169, 1156, 1, 0, 0, 0, 1170, 113, 1, 0, 0, 0, 1171,
		1172, 5, 172, 0, 0, 1172, 115, 1, 0, 0, 0, 1173, 1174, 5, 168, 0, 0, 1174,
		117, 1, 0, 0, 0, 1175, 1176, 3, 110, 55, 0, 1176, 119, 1, 0, 0, 0, 1177,
		1179, 5, 160, 0, 0, 1178, 1177, 1, 0, 0, 0, 1178, 1179, 1, 0, 0, 0, 1179,
		1180, 1, 0, 0, 0, 1180, 1190, 5, 170, 0, 0, 1181, 1183, 5, 160, 0, 0, 1182,
		1181, 1, 0, 0, 0, 1182, 1183, 1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184,
		1190, 5, 171, 0, 0, 1185, 1187, 5, 160, 0, 0, 1186, 1185, 1, 0, 0, 0, 1186,
		1187, 1, 0, 0, 0, 1187, 1188, 1, 0, 0, 0, 1188, 1190, 5, 169, 0, 0, 1189,
		1178, 1, 0, 0, 0, 1189, 1182, 1, 0, 0, 0, 1189, 1186, 1, 0, 0, 0, 1190,
		121, 1, 0, 0, 0, 1191, 1197, 5, 34, 0, 0, 1192, 1197, 3, 120, 60, 0, 1193,
		1197, 3, 100, 50, 0, 1194, 1197, 5, 168, 0, 0, 1195, 1197, 5, 176, 0, 0,
		1196, 1191, 1, 0, 0, 0, 1196, 1192, 1, 0, 0, 0, 1196, 1193, 1, 0, 0, 0,
		1196, 1194, 1, 0, 0, 0, 1196, 1195, 1, 0, 0, 0, 1197, 123, 1, 0, 0, 0,
		1198, 1199, 7, 11, 0, 0, 1199, 125, 1, 0, 0, 0, 154, 129, 141, 144, 157,
		161, 166, 171, 177, 190, 195, 210, 245, 248, 254, 258, 262, 267, 273, 278,
		286, 289, 295, 299, 303, 308, 314, 319, 330, 341, 349, 358, 363, 369, 374,
		380, 386, 393, 403, 414, 420, 426, 429, 434, 439, 443, 446, 448, 454, 464,
		473, 477, 483, 487, 489, 497, 505, 512, 516, 521, 526, 530, 534, 537, 547,
		558, 566, 569, 577, 585, 592, 599, 602, 605, 623, 628, 637, 641, 657, 661,
		671, 675, 686, 695, 698, 701, 708, 717, 720, 723, 731, 734, 740, 743, 754,
		760, 763, 769, 774, 778, 782, 786, 788, 799, 803, 805, 815, 818, 826, 839,
		847, 849, 854, 860, 868, 877, 883, 889, 893, 898, 903, 909, 923, 925, 938,
		942, 950, 954, 972, 975, 990, 993, 1008, 1011, 1026, 1033, 1036, 1049,
		1059, 1061, 1066, 1099, 1102, 1119, 1124, 1126, 1132, 1150, 1162, 1169,
		1178, 1182, 1186, 1189, 1196,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SqlBaseParserInit initializes any static state used to implement SqlBaseParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSqlBaseParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SqlBaseParserInit() {
	staticData := &SqlBaseParserStaticData
	staticData.once.Do(sqlbaseParserInit)
}

// NewSqlBaseParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSqlBaseParser(input antlr.TokenStream) *SqlBaseParser {
	SqlBaseParserInit()
	this := new(SqlBaseParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SqlBaseParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SqlBase.g4"

	return this
}

// SqlBaseParser tokens.
const (
	SqlBaseParserEOF                   = antlr.TokenEOF
	SqlBaseParserT__0                  = 1
	SqlBaseParserT__1                  = 2
	SqlBaseParserT__2                  = 3
	SqlBaseParserT__3                  = 4
	SqlBaseParserT__4                  = 5
	SqlBaseParserT__5                  = 6
	SqlBaseParserT__6                  = 7
	SqlBaseParserT__7                  = 8
	SqlBaseParserEMIT                  = 9
	SqlBaseParserCHANGES               = 10
	SqlBaseParserFINAL                 = 11
	SqlBaseParserSELECT                = 12
	SqlBaseParserFROM                  = 13
	SqlBaseParserAS                    = 14
	SqlBaseParserALL                   = 15
	SqlBaseParserDISTINCT              = 16
	SqlBaseParserWHERE                 = 17
	SqlBaseParserWITHIN                = 18
	SqlBaseParserWINDOW                = 19
	SqlBaseParserGROUP                 = 20
	SqlBaseParserBY                    = 21
	SqlBaseParserHAVING                = 22
	SqlBaseParserLIMIT                 = 23
	SqlBaseParserAT                    = 24
	SqlBaseParserOR                    = 25
	SqlBaseParserAND                   = 26
	SqlBaseParserIN                    = 27
	SqlBaseParserNOT                   = 28
	SqlBaseParserEXISTS                = 29
	SqlBaseParserBETWEEN               = 30
	SqlBaseParserLIKE                  = 31
	SqlBaseParserESCAPE                = 32
	SqlBaseParserIS                    = 33
	SqlBaseParserNULL                  = 34
	SqlBaseParserTRUE                  = 35
	SqlBaseParserFALSE                 = 36
	SqlBaseParserINTEGER               = 37
	SqlBaseParserDATE                  = 38
	SqlBaseParserTIME                  = 39
	SqlBaseParserTIMESTAMP             = 40
	SqlBaseParserINTERVAL              = 41
	SqlBaseParserYEAR                  = 42
	SqlBaseParserMONTH                 = 43
	SqlBaseParserDAY                   = 44
	SqlBaseParserHOUR                  = 45
	SqlBaseParserMINUTE                = 46
	SqlBaseParserSECOND                = 47
	SqlBaseParserMILLISECOND           = 48
	SqlBaseParserYEARS                 = 49
	SqlBaseParserMONTHS                = 50
	SqlBaseParserDAYS                  = 51
	SqlBaseParserHOURS                 = 52
	SqlBaseParserMINUTES               = 53
	SqlBaseParserSECONDS               = 54
	SqlBaseParserMILLISECONDS          = 55
	SqlBaseParserZONE                  = 56
	SqlBaseParserTUMBLING              = 57
	SqlBaseParserHOPPING               = 58
	SqlBaseParserSIZE                  = 59
	SqlBaseParserADVANCE               = 60
	SqlBaseParserRETENTION             = 61
	SqlBaseParserGRACE                 = 62
	SqlBaseParserPERIOD                = 63
	SqlBaseParserCASE                  = 64
	SqlBaseParserWHEN                  = 65
	SqlBaseParserTHEN                  = 66
	SqlBaseParserELSE                  = 67
	SqlBaseParserEND                   = 68
	SqlBaseParserJOIN                  = 69
	SqlBaseParserFULL                  = 70
	SqlBaseParserOUTER                 = 71
	SqlBaseParserINNER                 = 72
	SqlBaseParserLEFT                  = 73
	SqlBaseParserRIGHT                 = 74
	SqlBaseParserON                    = 75
	SqlBaseParserPARTITION             = 76
	SqlBaseParserSTRUCT                = 77
	SqlBaseParserWITH                  = 78
	SqlBaseParserVALUES                = 79
	SqlBaseParserCREATE                = 80
	SqlBaseParserTABLE                 = 81
	SqlBaseParserTOPIC                 = 82
	SqlBaseParserSTREAM                = 83
	SqlBaseParserSTREAMS               = 84
	SqlBaseParserINSERT                = 85
	SqlBaseParserDELETE                = 86
	SqlBaseParserINTO                  = 87
	SqlBaseParserDESCRIBE              = 88
	SqlBaseParserEXTENDED              = 89
	SqlBaseParserPRINT                 = 90
	SqlBaseParserEXPLAIN               = 91
	SqlBaseParserANALYZE               = 92
	SqlBaseParserTYPE                  = 93
	SqlBaseParserTYPES                 = 94
	SqlBaseParserCAST                  = 95
	SqlBaseParserSHOW                  = 96
	SqlBaseParserLIST                  = 97
	SqlBaseParserTABLES                = 98
	SqlBaseParserTOPICS                = 99
	SqlBaseParserQUERY                 = 100
	SqlBaseParserQUERIES               = 101
	SqlBaseParserTERMINATE             = 102
	SqlBaseParserPAUSE                 = 103
	SqlBaseParserRESUME                = 104
	SqlBaseParserLOAD                  = 105
	SqlBaseParserCOLUMNS               = 106
	SqlBaseParserCOLUMN                = 107
	SqlBaseParserPARTITIONS            = 108
	SqlBaseParserFUNCTIONS             = 109
	SqlBaseParserFUNCTION              = 110
	SqlBaseParserDROP                  = 111
	SqlBaseParserTO                    = 112
	SqlBaseParserRENAME                = 113
	SqlBaseParserARRAY                 = 114
	SqlBaseParserMAP                   = 115
	SqlBaseParserSET                   = 116
	SqlBaseParserDEFINE                = 117
	SqlBaseParserUNDEFINE              = 118
	SqlBaseParserRESET                 = 119
	SqlBaseParserSESSION               = 120
	SqlBaseParserSAMPLE                = 121
	SqlBaseParserEXPORT                = 122
	SqlBaseParserCATALOG               = 123
	SqlBaseParserPROPERTIES            = 124
	SqlBaseParserBEGINNING             = 125
	SqlBaseParserUNSET                 = 126
	SqlBaseParserRUN                   = 127
	SqlBaseParserSCRIPT                = 128
	SqlBaseParserDECIMAL               = 129
	SqlBaseParserKEY                   = 130
	SqlBaseParserCONNECTOR             = 131
	SqlBaseParserCONNECTORS            = 132
	SqlBaseParserSINK                  = 133
	SqlBaseParserSOURCE                = 134
	SqlBaseParserNAMESPACE             = 135
	SqlBaseParserMATERIALIZED          = 136
	SqlBaseParserVIEW                  = 137
	SqlBaseParserPRIMARY               = 138
	SqlBaseParserREPLACE               = 139
	SqlBaseParserASSERT                = 140
	SqlBaseParserADD                   = 141
	SqlBaseParserALTER                 = 142
	SqlBaseParserVARIABLES             = 143
	SqlBaseParserPLUGINS               = 144
	SqlBaseParserHEADERS               = 145
	SqlBaseParserHEADER                = 146
	SqlBaseParserSYSTEM                = 147
	SqlBaseParserTIMEOUT               = 148
	SqlBaseParserSCHEMA                = 149
	SqlBaseParserSUBJECT               = 150
	SqlBaseParserID                    = 151
	SqlBaseParserIF                    = 152
	SqlBaseParserEQ                    = 153
	SqlBaseParserNEQ                   = 154
	SqlBaseParserLT                    = 155
	SqlBaseParserLTE                   = 156
	SqlBaseParserGT                    = 157
	SqlBaseParserGTE                   = 158
	SqlBaseParserPLUS                  = 159
	SqlBaseParserMINUS                 = 160
	SqlBaseParserASTERISK              = 161
	SqlBaseParserSLASH                 = 162
	SqlBaseParserPERCENT               = 163
	SqlBaseParserCONCAT                = 164
	SqlBaseParserASSIGN                = 165
	SqlBaseParserSTRUCT_FIELD_REF      = 166
	SqlBaseParserLAMBDA_EXPRESSION     = 167
	SqlBaseParserSTRING                = 168
	SqlBaseParserINTEGER_VALUE         = 169
	SqlBaseParserDECIMAL_VALUE         = 170
	SqlBaseParserFLOATING_POINT_VALUE  = 171
	SqlBaseParserIDENTIFIER            = 172
	SqlBaseParserDIGIT_IDENTIFIER      = 173
	SqlBaseParserQUOTED_IDENTIFIER     = 174
	SqlBaseParserBACKQUOTED_IDENTIFIER = 175
	SqlBaseParserVARIABLE              = 176
	SqlBaseParserSIMPLE_COMMENT        = 177
	SqlBaseParserDIRECTIVE_COMMENT     = 178
	SqlBaseParserBRACKETED_COMMENT     = 179
	SqlBaseParserWS                    = 180
	SqlBaseParserUNRECOGNIZED          = 181
	SqlBaseParserDELIMITER             = 182
)

// SqlBaseParser rules.
const (
	SqlBaseParserRULE_statements               = 0
	SqlBaseParserRULE_testStatement            = 1
	SqlBaseParserRULE_singleStatement          = 2
	SqlBaseParserRULE_singleExpression         = 3
	SqlBaseParserRULE_statement                = 4
	SqlBaseParserRULE_assertStatement          = 5
	SqlBaseParserRULE_runScript                = 6
	SqlBaseParserRULE_resourceName             = 7
	SqlBaseParserRULE_query                    = 8
	SqlBaseParserRULE_resultMaterialization    = 9
	SqlBaseParserRULE_timeout                  = 10
	SqlBaseParserRULE_alterOption              = 11
	SqlBaseParserRULE_tableElements            = 12
	SqlBaseParserRULE_tableElement             = 13
	SqlBaseParserRULE_columnConstraints        = 14
	SqlBaseParserRULE_tableProperties          = 15
	SqlBaseParserRULE_tableProperty            = 16
	SqlBaseParserRULE_printClause              = 17
	SqlBaseParserRULE_intervalClause           = 18
	SqlBaseParserRULE_limitClause              = 19
	SqlBaseParserRULE_retentionClause          = 20
	SqlBaseParserRULE_gracePeriodClause        = 21
	SqlBaseParserRULE_windowExpression         = 22
	SqlBaseParserRULE_tumblingWindowExpression = 23
	SqlBaseParserRULE_hoppingWindowExpression  = 24
	SqlBaseParserRULE_sessionWindowExpression  = 25
	SqlBaseParserRULE_windowUnit               = 26
	SqlBaseParserRULE_groupBy                  = 27
	SqlBaseParserRULE_partitionBy              = 28
	SqlBaseParserRULE_values                   = 29
	SqlBaseParserRULE_selectItem               = 30
	SqlBaseParserRULE_relation                 = 31
	SqlBaseParserRULE_joinedSource             = 32
	SqlBaseParserRULE_joinType                 = 33
	SqlBaseParserRULE_joinWindow               = 34
	SqlBaseParserRULE_withinExpression         = 35
	SqlBaseParserRULE_joinWindowSize           = 36
	SqlBaseParserRULE_joinCriteria             = 37
	SqlBaseParserRULE_aliasedRelation          = 38
	SqlBaseParserRULE_columns                  = 39
	SqlBaseParserRULE_relationPrimary          = 40
	SqlBaseParserRULE_expression               = 41
	SqlBaseParserRULE_booleanExpression        = 42
	SqlBaseParserRULE_predicated               = 43
	SqlBaseParserRULE_predicate                = 44
	SqlBaseParserRULE_valueExpression          = 45
	SqlBaseParserRULE_primaryExpression        = 46
	SqlBaseParserRULE_functionArgument         = 47
	SqlBaseParserRULE_timeZoneSpecifier        = 48
	SqlBaseParserRULE_comparisonOperator       = 49
	SqlBaseParserRULE_booleanValue             = 50
	SqlBaseParserRULE_type                     = 51
	SqlBaseParserRULE_typeParameter            = 52
	SqlBaseParserRULE_baseType                 = 53
	SqlBaseParserRULE_whenClause               = 54
	SqlBaseParserRULE_identifier               = 55
	SqlBaseParserRULE_lambdaFunction           = 56
	SqlBaseParserRULE_variableName             = 57
	SqlBaseParserRULE_variableValue            = 58
	SqlBaseParserRULE_sourceName               = 59
	SqlBaseParserRULE_number                   = 60
	SqlBaseParserRULE_literal                  = 61
	SqlBaseParserRULE_nonReserved              = 62
)

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSingleStatement() []ISingleStatementContext
	SingleStatement(i int) ISingleStatementContext

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statements
	return p
}

func InitEmptyStatementsContext(p *StatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statements
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *StatementsContext) AllSingleStatement() []ISingleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleStatementContext); ok {
			len++
		}
	}

	tst := make([]ISingleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleStatementContext); ok {
			tst[i] = t.(ISingleStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *SqlBaseParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SqlBaseParserRULE_statements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserSELECT || ((int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&5764678374991793441) != 0) {
		{
			p.SetState(126)
			p.SingleStatement()
		}

		p.SetState(131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(132)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITestStatementContext is an interface to support dynamic dispatch.
type ITestStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleStatement() ISingleStatementContext
	AssertStatement() IAssertStatementContext
	RunScript() IRunScriptContext
	EOF() antlr.TerminalNode

	// IsTestStatementContext differentiates from other interfaces.
	IsTestStatementContext()
}

type TestStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestStatementContext() *TestStatementContext {
	var p = new(TestStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_testStatement
	return p
}

func InitEmptyTestStatementContext(p *TestStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_testStatement
}

func (*TestStatementContext) IsTestStatementContext() {}

func NewTestStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestStatementContext {
	var p = new(TestStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_testStatement

	return p
}

func (s *TestStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TestStatementContext) SingleStatement() ISingleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *TestStatementContext) AssertStatement() IAssertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *TestStatementContext) RunScript() IRunScriptContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRunScriptContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRunScriptContext)
}

func (s *TestStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *TestStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTestStatement(s)
	}
}

func (s *TestStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTestStatement(s)
	}
}

func (p *SqlBaseParser) TestStatement() (localctx ITestStatementContext) {
	localctx = NewTestStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SqlBaseParserRULE_testStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(134)
			p.SingleStatement()
		}

	case 2:
		{
			p.SetState(135)
			p.AssertStatement()
		}
		{
			p.SetState(136)
			p.Match(SqlBaseParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(138)
			p.RunScript()
		}
		{
			p.SetState(139)
			p.Match(SqlBaseParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(144)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(143)
			p.Match(SqlBaseParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *SqlBaseParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SqlBaseParserRULE_singleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(146)
		p.Statement()
	}
	{
		p.SetState(147)
		p.Match(SqlBaseParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	EOF() antlr.TerminalNode

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleExpression
	return p
}

func InitEmptySingleExpressionContext(p *SingleExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_singleExpression
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEOF, 0)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSingleExpression(s)
	}
}

func (s *SingleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSingleExpression(s)
	}
}

func (p *SqlBaseParser) SingleExpression() (localctx ISingleExpressionContext) {
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SqlBaseParserRULE_singleExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(149)
		p.Expression()
	}
	{
		p.SetState(150)
		p.Match(SqlBaseParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ListTablesContext struct {
	StatementContext
}

func NewListTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTablesContext {
	var p = new(ListTablesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *ListTablesContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListTablesContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *ListTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListTables(s)
	}
}

func (s *ListTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListTables(s)
	}
}

type DefineVariableContext struct {
	StatementContext
}

func NewDefineVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefineVariableContext {
	var p = new(DefineVariableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DefineVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineVariableContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINE, 0)
}

func (s *DefineVariableContext) VariableName() IVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *DefineVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *DefineVariableContext) VariableValue() IVariableValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableValueContext)
}

func (s *DefineVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDefineVariable(s)
	}
}

func (s *DefineVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDefineVariable(s)
	}
}

type ExplainContext struct {
	StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExplain(s)
	}
}

type CreateTableContext struct {
	StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateTableContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateTableContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateTableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateTableContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOURCE, 0)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateTableContext) TableElements() ITableElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *CreateTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateTableContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type AlterSystemPropertyContext struct {
	StatementContext
}

func NewAlterSystemPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSystemPropertyContext {
	var p = new(AlterSystemPropertyContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AlterSystemPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemPropertyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AlterSystemPropertyContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM, 0)
}

func (s *AlterSystemPropertyContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserSTRING)
}

func (s *AlterSystemPropertyContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, i)
}

func (s *AlterSystemPropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *AlterSystemPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAlterSystemProperty(s)
	}
}

func (s *AlterSystemPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAlterSystemProperty(s)
	}
}

type UnsetPropertyContext struct {
	StatementContext
}

func NewUnsetPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsetPropertyContext {
	var p = new(UnsetPropertyContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UnsetPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetPropertyContext) UNSET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNSET, 0)
}

func (s *UnsetPropertyContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *UnsetPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnsetProperty(s)
	}
}

func (s *UnsetPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnsetProperty(s)
	}
}

type ListTypesContext struct {
	StatementContext
}

func NewListTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTypesContext {
	var p = new(ListTypesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTypesContext) TYPES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPES, 0)
}

func (s *ListTypesContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListTypesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListTypes(s)
	}
}

func (s *ListTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListTypes(s)
	}
}

type DescribeFunctionContext struct {
	StatementContext
}

func NewDescribeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeFunctionContext {
	var p = new(DescribeFunctionContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeFunctionContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *DescribeFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDescribeFunction(s)
	}
}

func (s *DescribeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDescribeFunction(s)
	}
}

type RegisterTypeContext struct {
	StatementContext
}

func NewRegisterTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegisterTypeContext {
	var p = new(RegisterTypeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *RegisterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegisterTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *RegisterTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *RegisterTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RegisterTypeContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *RegisterTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *RegisterTypeContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *RegisterTypeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *RegisterTypeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *RegisterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRegisterType(s)
	}
}

func (s *RegisterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRegisterType(s)
	}
}

type ListTopicsContext struct {
	StatementContext
}

func NewListTopicsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTopicsContext {
	var p = new(ListTopicsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListTopicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTopicsContext) TOPICS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTOPICS, 0)
}

func (s *ListTopicsContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListTopicsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListTopicsContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *ListTopicsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *ListTopicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListTopics(s)
	}
}

func (s *ListTopicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListTopics(s)
	}
}

type ListQueriesContext struct {
	StatementContext
}

func NewListQueriesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListQueriesContext {
	var p = new(ListQueriesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListQueriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListQueriesContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUERIES, 0)
}

func (s *ListQueriesContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListQueriesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListQueriesContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *ListQueriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListQueries(s)
	}
}

func (s *ListQueriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListQueries(s)
	}
}

type DropStreamContext struct {
	StatementContext
}

func NewDropStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStreamContext {
	var p = new(DropStreamContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStreamContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAM, 0)
}

func (s *DropStreamContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *DropStreamContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropStreamContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropStreamContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *DropStreamContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTOPIC, 0)
}

func (s *DropStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropStream(s)
	}
}

func (s *DropStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropStream(s)
	}
}

type AssertTopicContext struct {
	StatementContext
}

func NewAssertTopicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTopicContext {
	var p = new(AssertTopicContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AssertTopicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTopicContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSERT, 0)
}

func (s *AssertTopicContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTOPIC, 0)
}

func (s *AssertTopicContext) ResourceName() IResourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceNameContext)
}

func (s *AssertTopicContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *AssertTopicContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *AssertTopicContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *AssertTopicContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertTopicContext) Timeout() ITimeoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeoutContext)
}

func (s *AssertTopicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAssertTopic(s)
	}
}

func (s *AssertTopicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAssertTopic(s)
	}
}

type QueryStatementContext struct {
	StatementContext
}

func NewQueryStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryStatementContext {
	var p = new(QueryStatementContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

type CreateStreamAsContext struct {
	StatementContext
}

func NewCreateStreamAsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStreamAsContext {
	var p = new(CreateStreamAsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateStreamAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStreamAsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateStreamAsContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAM, 0)
}

func (s *CreateStreamAsContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateStreamAsContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateStreamAsContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateStreamAsContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateStreamAsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateStreamAsContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateStreamAsContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateStreamAsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateStreamAsContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateStreamAsContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateStreamAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateStreamAs(s)
	}
}

func (s *CreateStreamAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateStreamAs(s)
	}
}

type CreateTableAsContext struct {
	StatementContext
}

func NewCreateTableAsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsContext {
	var p = new(CreateTableAsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateTableAsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *CreateTableAsContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateTableAsContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CreateTableAsContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableAsContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateTableAsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateTableAsContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateTableAsContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateTableAsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateTableAsContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateTableAsContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateTableAs(s)
	}
}

func (s *CreateTableAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateTableAs(s)
	}
}

type CreateConnectorContext struct {
	StatementContext
}

func NewCreateConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateConnectorContext {
	var p = new(CreateConnectorContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateConnectorContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONNECTOR, 0)
}

func (s *CreateConnectorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateConnectorContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateConnectorContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateConnectorContext) SINK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSINK, 0)
}

func (s *CreateConnectorContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOURCE, 0)
}

func (s *CreateConnectorContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateConnectorContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateConnectorContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateConnector(s)
	}
}

func (s *CreateConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateConnector(s)
	}
}

type CreateStreamContext struct {
	StatementContext
}

func NewCreateStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStreamContext {
	var p = new(CreateStreamContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStreamContext) CREATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCREATE, 0)
}

func (s *CreateStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAM, 0)
}

func (s *CreateStreamContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateStreamContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *CreateStreamContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *CreateStreamContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOURCE, 0)
}

func (s *CreateStreamContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *CreateStreamContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *CreateStreamContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *CreateStreamContext) TableElements() ITableElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *CreateStreamContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *CreateStreamContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCreateStream(s)
	}
}

func (s *CreateStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCreateStream(s)
	}
}

type ListConnectorsContext struct {
	StatementContext
}

func NewListConnectorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListConnectorsContext {
	var p = new(ListConnectorsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListConnectorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListConnectorsContext) CONNECTORS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONNECTORS, 0)
}

func (s *ListConnectorsContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListConnectorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListConnectorsContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOURCE, 0)
}

func (s *ListConnectorsContext) SINK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSINK, 0)
}

func (s *ListConnectorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListConnectors(s)
	}
}

func (s *ListConnectorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListConnectors(s)
	}
}

type ListVariablesContext struct {
	StatementContext
}

func NewListVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListVariablesContext {
	var p = new(ListVariablesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListVariablesContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIABLES, 0)
}

func (s *ListVariablesContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListVariablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListVariables(s)
	}
}

func (s *ListVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListVariables(s)
	}
}

type PauseQueryContext struct {
	StatementContext
}

func NewPauseQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseQueryContext {
	var p = new(PauseQueryContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *PauseQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseQueryContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPAUSE, 0)
}

func (s *PauseQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PauseQueryContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *PauseQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPauseQuery(s)
	}
}

func (s *PauseQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPauseQuery(s)
	}
}

type ListStreamsContext struct {
	StatementContext
}

func NewListStreamsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListStreamsContext {
	var p = new(ListStreamsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListStreamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListStreamsContext) STREAMS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAMS, 0)
}

func (s *ListStreamsContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListStreamsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListStreamsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *ListStreamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListStreams(s)
	}
}

func (s *ListStreamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListStreams(s)
	}
}

type ShowColumnsContext struct {
	StatementContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *ShowColumnsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type ResumeQueryContext struct {
	StatementContext
}

func NewResumeQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeQueryContext {
	var p = new(ResumeQueryContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ResumeQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeQueryContext) RESUME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESUME, 0)
}

func (s *ResumeQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeQueryContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *ResumeQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterResumeQuery(s)
	}
}

func (s *ResumeQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitResumeQuery(s)
	}
}

type DropTableContext struct {
	StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *DropTableContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropTableContext) DELETE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDELETE, 0)
}

func (s *DropTableContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTOPIC, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type DropConnectorContext struct {
	StatementContext
}

func NewDropConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropConnectorContext {
	var p = new(DropConnectorContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConnectorContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONNECTOR, 0)
}

func (s *DropConnectorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropConnectorContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropConnectorContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropConnector(s)
	}
}

func (s *DropConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropConnector(s)
	}
}

type ListConnectorPluginsContext struct {
	StatementContext
}

func NewListConnectorPluginsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListConnectorPluginsContext {
	var p = new(ListConnectorPluginsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListConnectorPluginsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListConnectorPluginsContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONNECTOR, 0)
}

func (s *ListConnectorPluginsContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUGINS, 0)
}

func (s *ListConnectorPluginsContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListConnectorPluginsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListConnectorPluginsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListConnectorPlugins(s)
	}
}

func (s *ListConnectorPluginsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListConnectorPlugins(s)
	}
}

type ListFunctionsContext struct {
	StatementContext
}

func NewListFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListFunctionsContext {
	var p = new(ListFunctionsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *ListFunctionsContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListFunctions(s)
	}
}

func (s *ListFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListFunctions(s)
	}
}

type DescribeConnectorContext struct {
	StatementContext
}

func NewDescribeConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeConnectorContext {
	var p = new(DescribeConnectorContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeConnectorContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONNECTOR, 0)
}

func (s *DescribeConnectorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDescribeConnector(s)
	}
}

func (s *DescribeConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDescribeConnector(s)
	}
}

type InsertIntoContext struct {
	StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *InsertIntoContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *InsertIntoContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertIntoContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *InsertIntoContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

type AlterSourceContext struct {
	StatementContext
}

func NewAlterSourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSourceContext {
	var p = new(AlterSourceContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AlterSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSourceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *AlterSourceContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AlterSourceContext) AllAlterOption() []IAlterOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterOptionContext); ok {
			len++
		}
	}

	tst := make([]IAlterOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterOptionContext); ok {
			tst[i] = t.(IAlterOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterSourceContext) AlterOption(i int) IAlterOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterOptionContext)
}

func (s *AlterSourceContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAM, 0)
}

func (s *AlterSourceContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AlterSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAlterSource(s)
	}
}

func (s *AlterSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAlterSource(s)
	}
}

type PrintTopicContext struct {
	StatementContext
}

func NewPrintTopicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrintTopicContext {
	var p = new(PrintTopicContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *PrintTopicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintTopicContext) PRINT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRINT, 0)
}

func (s *PrintTopicContext) ResourceName() IResourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceNameContext)
}

func (s *PrintTopicContext) PrintClause() IPrintClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintClauseContext)
}

func (s *PrintTopicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPrintTopic(s)
	}
}

func (s *PrintTopicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPrintTopic(s)
	}
}

type ListPropertiesContext struct {
	StatementContext
}

func NewListPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListPropertiesContext {
	var p = new(ListPropertiesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ListPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPROPERTIES, 0)
}

func (s *ListPropertiesContext) LIST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIST, 0)
}

func (s *ListPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *ListPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterListProperties(s)
	}
}

func (s *ListPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitListProperties(s)
	}
}

type AssertSchemaContext struct {
	StatementContext
}

func NewAssertSchemaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertSchemaContext {
	var p = new(AssertSchemaContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *AssertSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertSchemaContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSERT, 0)
}

func (s *AssertSchemaContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *AssertSchemaContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *AssertSchemaContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *AssertSchemaContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBJECT, 0)
}

func (s *AssertSchemaContext) ResourceName() IResourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceNameContext)
}

func (s *AssertSchemaContext) ID() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserID, 0)
}

func (s *AssertSchemaContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AssertSchemaContext) Timeout() ITimeoutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeoutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeoutContext)
}

func (s *AssertSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAssertSchema(s)
	}
}

func (s *AssertSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAssertSchema(s)
	}
}

type DropTypeContext struct {
	StatementContext
}

func NewDropTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTypeContext {
	var p = new(DropTypeContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTypeContext) DROP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDROP, 0)
}

func (s *DropTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *DropTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTypeContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *DropTypeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXISTS, 0)
}

func (s *DropTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDropType(s)
	}
}

func (s *DropTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDropType(s)
	}
}

type SetPropertyContext struct {
	StatementContext
}

func NewSetPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPropertyContext {
	var p = new(SetPropertyContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *SetPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPropertyContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *SetPropertyContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserSTRING)
}

func (s *SetPropertyContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, i)
}

func (s *SetPropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *SetPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSetProperty(s)
	}
}

func (s *SetPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSetProperty(s)
	}
}

type TerminateQueryContext struct {
	StatementContext
}

func NewTerminateQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TerminateQueryContext {
	var p = new(TerminateQueryContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *TerminateQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminateQueryContext) TERMINATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTERMINATE, 0)
}

func (s *TerminateQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TerminateQueryContext) ALL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALL, 0)
}

func (s *TerminateQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTerminateQuery(s)
	}
}

func (s *TerminateQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTerminateQuery(s)
	}
}

type UndefineVariableContext struct {
	StatementContext
}

func NewUndefineVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UndefineVariableContext {
	var p = new(UndefineVariableContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *UndefineVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UndefineVariableContext) UNDEFINE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNDEFINE, 0)
}

func (s *UndefineVariableContext) VariableName() IVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *UndefineVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUndefineVariable(s)
	}
}

func (s *UndefineVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUndefineVariable(s)
	}
}

type InsertValuesContext struct {
	StatementContext
}

func NewInsertValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertValuesContext {
	var p = new(InsertValuesContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *InsertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesContext) INSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINSERT, 0)
}

func (s *InsertValuesContext) INTO() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTO, 0)
}

func (s *InsertValuesContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *InsertValuesContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *InsertValuesContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *InsertValuesContext) Columns() IColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *InsertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInsertValues(s)
	}
}

func (s *InsertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInsertValues(s)
	}
}

type DescribeStreamsContext struct {
	StatementContext
}

func NewDescribeStreamsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeStreamsContext {
	var p = new(DescribeStreamsContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DescribeStreamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStreamsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDESCRIBE, 0)
}

func (s *DescribeStreamsContext) STREAMS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAMS, 0)
}

func (s *DescribeStreamsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXTENDED, 0)
}

func (s *DescribeStreamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDescribeStreams(s)
	}
}

func (s *DescribeStreamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDescribeStreams(s)
	}
}

func (p *SqlBaseParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SqlBaseParserRULE_statement)
	var _la int

	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQueryStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(152)
			p.Query()
		}

	case 2:
		localctx = NewListPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(153)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(154)
			p.Match(SqlBaseParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewListTopicsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(155)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserALL {
			{
				p.SetState(156)
				p.Match(SqlBaseParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(159)
			p.Match(SqlBaseParserTOPICS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserEXTENDED {
			{
				p.SetState(160)
				p.Match(SqlBaseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewListStreamsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(163)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(164)
			p.Match(SqlBaseParserSTREAMS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserEXTENDED {
			{
				p.SetState(165)
				p.Match(SqlBaseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewListTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(168)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(169)
			p.Match(SqlBaseParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserEXTENDED {
			{
				p.SetState(170)
				p.Match(SqlBaseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewListFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(173)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(174)
			p.Match(SqlBaseParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewListConnectorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(175)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserSINK || _la == SqlBaseParserSOURCE {
			{
				p.SetState(176)
				_la = p.GetTokenStream().LA(1)

				if !(_la == SqlBaseParserSINK || _la == SqlBaseParserSOURCE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(179)
			p.Match(SqlBaseParserCONNECTORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewListConnectorPluginsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(180)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(181)
			p.Match(SqlBaseParserCONNECTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(182)
			p.Match(SqlBaseParserPLUGINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewListTypesContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(183)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(184)
			p.Match(SqlBaseParserTYPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewListVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(185)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(186)
			p.Match(SqlBaseParserVARIABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(187)
			p.Match(SqlBaseParserDESCRIBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(188)
			p.SourceName()
		}
		p.SetState(190)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserEXTENDED {
			{
				p.SetState(189)
				p.Match(SqlBaseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 12:
		localctx = NewDescribeStreamsContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(192)
			p.Match(SqlBaseParserDESCRIBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(193)
			p.Match(SqlBaseParserSTREAMS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserEXTENDED {
			{
				p.SetState(194)
				p.Match(SqlBaseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 13:
		localctx = NewDescribeFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(197)
			p.Match(SqlBaseParserDESCRIBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(198)
			p.Match(SqlBaseParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(199)
			p.Identifier()
		}

	case 14:
		localctx = NewDescribeConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(200)
			p.Match(SqlBaseParserDESCRIBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(201)
			p.Match(SqlBaseParserCONNECTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(202)
			p.Identifier()
		}

	case 15:
		localctx = NewPrintTopicContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(203)
			p.Match(SqlBaseParserPRINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(204)
			p.ResourceName()
		}
		{
			p.SetState(205)
			p.PrintClause()
		}

	case 16:
		localctx = NewListQueriesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(207)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSHOW || _la == SqlBaseParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(208)
			p.Match(SqlBaseParserQUERIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserEXTENDED {
			{
				p.SetState(209)
				p.Match(SqlBaseParserEXTENDED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 17:
		localctx = NewTerminateQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(212)
			p.Match(SqlBaseParserTERMINATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(213)
			p.Identifier()
		}

	case 18:
		localctx = NewTerminateQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(214)
			p.Match(SqlBaseParserTERMINATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(215)
			p.Match(SqlBaseParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewPauseQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(216)
			p.Match(SqlBaseParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(217)
			p.Identifier()
		}

	case 20:
		localctx = NewPauseQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(218)
			p.Match(SqlBaseParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(219)
			p.Match(SqlBaseParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewResumeQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(220)
			p.Match(SqlBaseParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(221)
			p.Identifier()
		}

	case 22:
		localctx = NewResumeQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(222)
			p.Match(SqlBaseParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(223)
			p.Match(SqlBaseParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewSetPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(224)
			p.Match(SqlBaseParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(225)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(226)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(227)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewAlterSystemPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(228)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(229)
			p.Match(SqlBaseParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(230)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(231)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(232)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewUnsetPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(233)
			p.Match(SqlBaseParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(234)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		localctx = NewDefineVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(235)
			p.Match(SqlBaseParserDEFINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(236)
			p.VariableName()
		}
		{
			p.SetState(237)
			p.Match(SqlBaseParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(238)
			p.VariableValue()
		}

	case 27:
		localctx = NewUndefineVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(240)
			p.Match(SqlBaseParserUNDEFINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(241)
			p.VariableName()
		}

	case 28:
		localctx = NewCreateStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(242)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(243)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(244)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserSOURCE {
			{
				p.SetState(247)
				p.Match(SqlBaseParserSOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(250)
			p.Match(SqlBaseParserSTREAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(254)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(251)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(252)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(253)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(256)
			p.SourceName()
		}
		p.SetState(258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__2 {
			{
				p.SetState(257)
				p.TableElements()
			}

		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(260)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(261)
				p.TableProperties()
			}

		}

	case 29:
		localctx = NewCreateStreamAsContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(264)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(265)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(266)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(269)
			p.Match(SqlBaseParserSTREAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(270)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(271)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(272)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(275)
			p.SourceName()
		}
		p.SetState(278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(276)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(277)
				p.TableProperties()
			}

		}
		{
			p.SetState(280)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(281)
			p.Query()
		}

	case 30:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(283)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(286)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(284)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(285)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserSOURCE {
			{
				p.SetState(288)
				p.Match(SqlBaseParserSOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(291)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(295)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(292)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(293)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(294)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(297)
			p.SourceName()
		}
		p.SetState(299)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__2 {
			{
				p.SetState(298)
				p.TableElements()
			}

		}
		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(301)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(302)
				p.TableProperties()
			}

		}

	case 31:
		localctx = NewCreateTableAsContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(305)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOR {
			{
				p.SetState(306)
				p.Match(SqlBaseParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(307)
				p.Match(SqlBaseParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(310)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(314)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(311)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(312)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(313)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(316)
			p.SourceName()
		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(317)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(318)
				p.TableProperties()
			}

		}
		{
			p.SetState(321)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(322)
			p.Query()
		}

	case 32:
		localctx = NewCreateConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(324)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(325)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserSINK || _la == SqlBaseParserSOURCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(326)
			p.Match(SqlBaseParserCONNECTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(330)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(327)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(328)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(329)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(332)
			p.Identifier()
		}
		{
			p.SetState(333)
			p.Match(SqlBaseParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(334)
			p.TableProperties()
		}

	case 33:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(336)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(337)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(338)
			p.SourceName()
		}
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(339)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(340)
				p.TableProperties()
			}

		}
		{
			p.SetState(343)
			p.Query()
		}

	case 34:
		localctx = NewInsertValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(345)
			p.Match(SqlBaseParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(346)
			p.Match(SqlBaseParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(347)
			p.SourceName()
		}
		p.SetState(349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__2 {
			{
				p.SetState(348)
				p.Columns()
			}

		}
		{
			p.SetState(351)
			p.Match(SqlBaseParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(352)
			p.Values()
		}

	case 35:
		localctx = NewDropStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(354)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(355)
			p.Match(SqlBaseParserSTREAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(358)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(356)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(357)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(360)
			p.SourceName()
		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserDELETE {
			{
				p.SetState(361)
				p.Match(SqlBaseParserDELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(362)
				p.Match(SqlBaseParserTOPIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 36:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(365)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(366)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(369)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(367)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(368)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(371)
			p.SourceName()
		}
		p.SetState(374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserDELETE {
			{
				p.SetState(372)
				p.Match(SqlBaseParserDELETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(373)
				p.Match(SqlBaseParserTOPIC)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 37:
		localctx = NewDropConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(376)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(377)
			p.Match(SqlBaseParserCONNECTOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(380)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(378)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(379)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(382)
			p.Identifier()
		}

	case 38:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(383)
			p.Match(SqlBaseParserEXPLAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(384)
				p.Statement()
			}

		case 2:
			{
				p.SetState(385)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 39:
		localctx = NewRegisterTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(388)
			p.Match(SqlBaseParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(389)
			p.Match(SqlBaseParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(393)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(390)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(391)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(392)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(395)
			p.Identifier()
		}
		{
			p.SetState(396)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(397)
			p.type_(0)
		}

	case 40:
		localctx = NewDropTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(399)
			p.Match(SqlBaseParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(400)
			p.Match(SqlBaseParserTYPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(403)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(401)
				p.Match(SqlBaseParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(402)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(405)
			p.Identifier()
		}

	case 41:
		localctx = NewAlterSourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(406)
			p.Match(SqlBaseParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(407)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserTABLE || _la == SqlBaseParserSTREAM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(408)
			p.SourceName()
		}
		{
			p.SetState(409)
			p.AlterOption()
		}
		p.SetState(414)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__1 {
			{
				p.SetState(410)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(411)
				p.AlterOption()
			}

			p.SetState(416)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 42:
		localctx = NewAssertTopicContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(417)
			p.Match(SqlBaseParserASSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(418)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(419)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(422)
			p.Match(SqlBaseParserTOPIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(423)
			p.ResourceName()
		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(424)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(425)
				p.TableProperties()
			}

		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTIMEOUT {
			{
				p.SetState(428)
				p.Timeout()
			}

		}

	case 43:
		localctx = NewAssertSchemaContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(431)
			p.Match(SqlBaseParserASSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(432)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(433)
				p.Match(SqlBaseParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(436)
			p.Match(SqlBaseParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserSUBJECT {
			{
				p.SetState(437)
				p.Match(SqlBaseParserSUBJECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(438)
				p.ResourceName()
			}

		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserID {
			{
				p.SetState(441)
				p.Match(SqlBaseParserID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(442)
				p.Literal()
			}

		}
		p.SetState(446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserTIMEOUT {
			{
				p.SetState(445)
				p.Timeout()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assertStatement
	return p
}

func InitEmptyAssertStatementContext(p *AssertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_assertStatement
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) CopyAll(ctx *AssertStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AssertValuesContext struct {
	AssertStatementContext
}

func NewAssertValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertValuesContext {
	var p = new(AssertValuesContext)

	InitEmptyAssertStatementContext(&p.AssertStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertValuesContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSERT, 0)
}

func (s *AssertValuesContext) AllVALUES() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserVALUES)
}

func (s *AssertValuesContext) VALUES(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, i)
}

func (s *AssertValuesContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertValuesContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *AssertValuesContext) Columns() IColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *AssertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAssertValues(s)
	}
}

func (s *AssertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAssertValues(s)
	}
}

type AssertTombstoneContext struct {
	AssertStatementContext
}

func NewAssertTombstoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTombstoneContext {
	var p = new(AssertTombstoneContext)

	InitEmptyAssertStatementContext(&p.AssertStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertTombstoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTombstoneContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSERT, 0)
}

func (s *AssertTombstoneContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *AssertTombstoneContext) VALUES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVALUES, 0)
}

func (s *AssertTombstoneContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertTombstoneContext) KEY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEY, 0)
}

func (s *AssertTombstoneContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *AssertTombstoneContext) Columns() IColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *AssertTombstoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAssertTombstone(s)
	}
}

func (s *AssertTombstoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAssertTombstone(s)
	}
}

type AssertTableContext struct {
	AssertStatementContext
}

func NewAssertTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTableContext {
	var p = new(AssertTableContext)

	InitEmptyAssertStatementContext(&p.AssertStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTableContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSERT, 0)
}

func (s *AssertTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLE, 0)
}

func (s *AssertTableContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertTableContext) TableElements() ITableElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *AssertTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *AssertTableContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAssertTable(s)
	}
}

func (s *AssertTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAssertTable(s)
	}
}

type AssertStreamContext struct {
	AssertStatementContext
}

func NewAssertStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertStreamContext {
	var p = new(AssertStreamContext)

	InitEmptyAssertStatementContext(&p.AssertStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStreamContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSERT, 0)
}

func (s *AssertStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTREAM, 0)
}

func (s *AssertStreamContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertStreamContext) TableElements() ITableElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *AssertStreamContext) WITH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITH, 0)
}

func (s *AssertStreamContext) TableProperties() ITablePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAssertStream(s)
	}
}

func (s *AssertStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAssertStream(s)
	}
}

func (p *SqlBaseParser) AssertStatement() (localctx IAssertStatementContext) {
	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SqlBaseParserRULE_assertStatement)
	var _la int

	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAssertValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(450)
			p.Match(SqlBaseParserASSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(451)
			p.Match(SqlBaseParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(452)
			p.SourceName()
		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__2 {
			{
				p.SetState(453)
				p.Columns()
			}

		}
		{
			p.SetState(456)
			p.Match(SqlBaseParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(457)
			p.Values()
		}

	case 2:
		localctx = NewAssertTombstoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.Match(SqlBaseParserASSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(460)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(461)
			p.Match(SqlBaseParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(462)
			p.SourceName()
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__2 {
			{
				p.SetState(463)
				p.Columns()
			}

		}
		{
			p.SetState(466)
			p.Match(SqlBaseParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(467)
			p.Values()
		}

	case 3:
		localctx = NewAssertStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(469)
			p.Match(SqlBaseParserASSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(470)
			p.Match(SqlBaseParserSTREAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(471)
			p.SourceName()
		}
		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__2 {
			{
				p.SetState(472)
				p.TableElements()
			}

		}
		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(475)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(476)
				p.TableProperties()
			}

		}

	case 4:
		localctx = NewAssertTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(479)
			p.Match(SqlBaseParserASSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(480)
			p.Match(SqlBaseParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(481)
			p.SourceName()
		}
		p.SetState(483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserT__2 {
			{
				p.SetState(482)
				p.TableElements()
			}

		}
		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserWITH {
			{
				p.SetState(485)
				p.Match(SqlBaseParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(486)
				p.TableProperties()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRunScriptContext is an interface to support dynamic dispatch.
type IRunScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RUN() antlr.TerminalNode
	SCRIPT() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsRunScriptContext differentiates from other interfaces.
	IsRunScriptContext()
}

type RunScriptContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRunScriptContext() *RunScriptContext {
	var p = new(RunScriptContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_runScript
	return p
}

func InitEmptyRunScriptContext(p *RunScriptContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_runScript
}

func (*RunScriptContext) IsRunScriptContext() {}

func NewRunScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RunScriptContext {
	var p = new(RunScriptContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_runScript

	return p
}

func (s *RunScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *RunScriptContext) RUN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRUN, 0)
}

func (s *RunScriptContext) SCRIPT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCRIPT, 0)
}

func (s *RunScriptContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *RunScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RunScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RunScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRunScript(s)
	}
}

func (s *RunScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRunScript(s)
	}
}

func (p *SqlBaseParser) RunScript() (localctx IRunScriptContext) {
	localctx = NewRunScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SqlBaseParserRULE_runScript)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(SqlBaseParserRUN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(492)
		p.Match(SqlBaseParserSCRIPT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(493)
		p.Match(SqlBaseParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceNameContext is an interface to support dynamic dispatch.
type IResourceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING() antlr.TerminalNode

	// IsResourceNameContext differentiates from other interfaces.
	IsResourceNameContext()
}

type ResourceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceNameContext() *ResourceNameContext {
	var p = new(ResourceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_resourceName
	return p
}

func InitEmptyResourceNameContext(p *ResourceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_resourceName
}

func (*ResourceNameContext) IsResourceNameContext() {}

func NewResourceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceNameContext {
	var p = new(ResourceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_resourceName

	return p
}

func (s *ResourceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceNameContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *ResourceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterResourceName(s)
	}
}

func (s *ResourceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitResourceName(s)
	}
}

func (p *SqlBaseParser) ResourceName() (localctx IResourceNameContext) {
	localctx = NewResourceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SqlBaseParserRULE_resourceName)
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__7, SqlBaseParserEMIT, SqlBaseParserCHANGES, SqlBaseParserFINAL, SqlBaseParserESCAPE, SqlBaseParserINTEGER, SqlBaseParserDATE, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserINTERVAL, SqlBaseParserYEAR, SqlBaseParserMONTH, SqlBaseParserDAY, SqlBaseParserHOUR, SqlBaseParserMINUTE, SqlBaseParserSECOND, SqlBaseParserZONE, SqlBaseParserGRACE, SqlBaseParserPERIOD, SqlBaseParserPARTITION, SqlBaseParserSTRUCT, SqlBaseParserEXPLAIN, SqlBaseParserANALYZE, SqlBaseParserTYPE, SqlBaseParserTYPES, SqlBaseParserSHOW, SqlBaseParserTABLES, SqlBaseParserCOLUMNS, SqlBaseParserCOLUMN, SqlBaseParserPARTITIONS, SqlBaseParserFUNCTIONS, SqlBaseParserFUNCTION, SqlBaseParserARRAY, SqlBaseParserMAP, SqlBaseParserSET, SqlBaseParserDEFINE, SqlBaseParserUNDEFINE, SqlBaseParserRESET, SqlBaseParserSESSION, SqlBaseParserKEY, SqlBaseParserSINK, SqlBaseParserSOURCE, SqlBaseParserPRIMARY, SqlBaseParserREPLACE, SqlBaseParserASSERT, SqlBaseParserADD, SqlBaseParserALTER, SqlBaseParserVARIABLES, SqlBaseParserPLUGINS, SqlBaseParserHEADERS, SqlBaseParserHEADER, SqlBaseParserSYSTEM, SqlBaseParserTIMEOUT, SqlBaseParserSCHEMA, SqlBaseParserSUBJECT, SqlBaseParserID, SqlBaseParserIF, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserVARIABLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(495)
			p.Identifier()
		}

	case SqlBaseParserSTRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(496)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IRelationContext

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetFrom sets the from rule contexts.
	SetFrom(IRelationContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FROM() antlr.TerminalNode
	Relation() IRelationContext
	WINDOW() antlr.TerminalNode
	WindowExpression() IWindowExpressionContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	GroupBy() IGroupByContext
	PARTITION() antlr.TerminalNode
	PartitionBy() IPartitionByContext
	HAVING() antlr.TerminalNode
	EMIT() antlr.TerminalNode
	ResultMaterialization() IResultMaterializationContext
	LimitClause() ILimitClauseContext
	AllBooleanExpression() []IBooleanExpressionContext
	BooleanExpression(i int) IBooleanExpressionContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IRelationContext
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) GetFrom() IRelationContext { return s.from }

func (s *QueryContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QueryContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QueryContext) SetFrom(v IRelationContext) { s.from = v }

func (s *QueryContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QueryContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QueryContext) SELECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSELECT, 0)
}

func (s *QueryContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QueryContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *QueryContext) Relation() IRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QueryContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWINDOW, 0)
}

func (s *QueryContext) WindowExpression() IWindowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowExpressionContext)
}

func (s *QueryContext) WHERE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHERE, 0)
}

func (s *QueryContext) GROUP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGROUP, 0)
}

func (s *QueryContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserBY)
}

func (s *QueryContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, i)
}

func (s *QueryContext) GroupBy() IGroupByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QueryContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *QueryContext) PartitionBy() IPartitionByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionByContext)
}

func (s *QueryContext) HAVING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHAVING, 0)
}

func (s *QueryContext) EMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEMIT, 0)
}

func (s *QueryContext) ResultMaterialization() IResultMaterializationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResultMaterializationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResultMaterializationContext)
}

func (s *QueryContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QueryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *SqlBaseParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SqlBaseParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.Match(SqlBaseParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(500)
		p.SelectItem()
	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__1 {
		{
			p.SetState(501)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.SelectItem()
		}

		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(508)
		p.Match(SqlBaseParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(509)

		var _x = p.Relation()

		localctx.(*QueryContext).from = _x
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWINDOW {
		{
			p.SetState(510)
			p.Match(SqlBaseParserWINDOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(511)
			p.WindowExpression()
		}

	}
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWHERE {
		{
			p.SetState(514)
			p.Match(SqlBaseParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(515)

			var _x = p.booleanExpression(0)

			localctx.(*QueryContext).where = _x
		}

	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserGROUP {
		{
			p.SetState(518)
			p.Match(SqlBaseParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(519)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(520)
			p.GroupBy()
		}

	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserPARTITION {
		{
			p.SetState(523)
			p.Match(SqlBaseParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(524)
			p.Match(SqlBaseParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(525)
			p.PartitionBy()
		}

	}
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserHAVING {
		{
			p.SetState(528)
			p.Match(SqlBaseParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(529)

			var _x = p.booleanExpression(0)

			localctx.(*QueryContext).having = _x
		}

	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserEMIT {
		{
			p.SetState(532)
			p.Match(SqlBaseParserEMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(533)
			p.ResultMaterialization()
		}

	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserLIMIT {
		{
			p.SetState(536)
			p.LimitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResultMaterializationContext is an interface to support dynamic dispatch.
type IResultMaterializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGES() antlr.TerminalNode
	FINAL() antlr.TerminalNode

	// IsResultMaterializationContext differentiates from other interfaces.
	IsResultMaterializationContext()
}

type ResultMaterializationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultMaterializationContext() *ResultMaterializationContext {
	var p = new(ResultMaterializationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_resultMaterialization
	return p
}

func InitEmptyResultMaterializationContext(p *ResultMaterializationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_resultMaterialization
}

func (*ResultMaterializationContext) IsResultMaterializationContext() {}

func NewResultMaterializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultMaterializationContext {
	var p = new(ResultMaterializationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_resultMaterialization

	return p
}

func (s *ResultMaterializationContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultMaterializationContext) CHANGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHANGES, 0)
}

func (s *ResultMaterializationContext) FINAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFINAL, 0)
}

func (s *ResultMaterializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultMaterializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultMaterializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterResultMaterialization(s)
	}
}

func (s *ResultMaterializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitResultMaterialization(s)
	}
}

func (p *SqlBaseParser) ResultMaterialization() (localctx IResultMaterializationContext) {
	localctx = NewResultMaterializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, SqlBaseParserRULE_resultMaterialization)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserCHANGES || _la == SqlBaseParserFINAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeoutContext is an interface to support dynamic dispatch.
type ITimeoutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TIMEOUT() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext

	// IsTimeoutContext differentiates from other interfaces.
	IsTimeoutContext()
}

type TimeoutContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeoutContext() *TimeoutContext {
	var p = new(TimeoutContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timeout
	return p
}

func InitEmptyTimeoutContext(p *TimeoutContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timeout
}

func (*TimeoutContext) IsTimeoutContext() {}

func NewTimeoutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeoutContext {
	var p = new(TimeoutContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_timeout

	return p
}

func (s *TimeoutContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeoutContext) TIMEOUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMEOUT, 0)
}

func (s *TimeoutContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *TimeoutContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *TimeoutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeoutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeoutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTimeout(s)
	}
}

func (s *TimeoutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTimeout(s)
	}
}

func (p *SqlBaseParser) Timeout() (localctx ITimeoutContext) {
	localctx = NewTimeoutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SqlBaseParserRULE_timeout)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Match(SqlBaseParserTIMEOUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(542)
		p.Number()
	}
	{
		p.SetState(543)
		p.WindowUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterOptionContext is an interface to support dynamic dispatch.
type IAlterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	Identifier() IIdentifierContext
	Type_() ITypeContext
	COLUMN() antlr.TerminalNode

	// IsAlterOptionContext differentiates from other interfaces.
	IsAlterOptionContext()
}

type AlterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterOptionContext() *AlterOptionContext {
	var p = new(AlterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterOption
	return p
}

func InitEmptyAlterOptionContext(p *AlterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_alterOption
}

func (*AlterOptionContext) IsAlterOptionContext() {}

func NewAlterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterOptionContext {
	var p = new(AlterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_alterOption

	return p
}

func (s *AlterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterOptionContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *AlterOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterOptionContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AlterOptionContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *AlterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAlterOption(s)
	}
}

func (s *AlterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAlterOption(s)
	}
}

func (p *SqlBaseParser) AlterOption() (localctx IAlterOptionContext) {
	localctx = NewAlterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SqlBaseParserRULE_alterOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(545)
		p.Match(SqlBaseParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(546)
			p.Match(SqlBaseParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(549)
		p.Identifier()
	}
	{
		p.SetState(550)
		p.type_(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementsContext is an interface to support dynamic dispatch.
type ITableElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableElement() []ITableElementContext
	TableElement(i int) ITableElementContext

	// IsTableElementsContext differentiates from other interfaces.
	IsTableElementsContext()
}

type TableElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementsContext() *TableElementsContext {
	var p = new(TableElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElements
	return p
}

func InitEmptyTableElementsContext(p *TableElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElements
}

func (*TableElementsContext) IsTableElementsContext() {}

func NewTableElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementsContext {
	var p = new(TableElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableElements

	return p
}

func (s *TableElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementsContext) AllTableElement() []ITableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableElementContext); ok {
			len++
		}
	}

	tst := make([]ITableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableElementContext); ok {
			tst[i] = t.(ITableElementContext)
			i++
		}
	}

	return tst
}

func (s *TableElementsContext) TableElement(i int) ITableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *TableElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableElements(s)
	}
}

func (s *TableElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableElements(s)
	}
}

func (p *SqlBaseParser) TableElements() (localctx ITableElementsContext) {
	localctx = NewTableElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SqlBaseParserRULE_tableElements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(553)
		p.TableElement()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__1 {
		{
			p.SetState(554)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(555)
			p.TableElement()
		}

		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(561)
		p.Match(SqlBaseParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext
	ColumnConstraints() IColumnConstraintsContext

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElement
	return p
}

func InitEmptyTableElementContext(p *TableElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableElement
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableElementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TableElementContext) ColumnConstraints() IColumnConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintsContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (p *SqlBaseParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SqlBaseParserRULE_tableElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(563)
		p.Identifier()
	}
	{
		p.SetState(564)
		p.type_(0)
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&98561) != 0 {
		{
			p.SetState(565)
			p.ColumnConstraints()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnConstraintsContext is an interface to support dynamic dispatch.
type IColumnConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	HEADERS() antlr.TerminalNode
	HEADER() antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsColumnConstraintsContext differentiates from other interfaces.
	IsColumnConstraintsContext()
}

type ColumnConstraintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintsContext() *ColumnConstraintsContext {
	var p = new(ColumnConstraintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnConstraints
	return p
}

func InitEmptyColumnConstraintsContext(p *ColumnConstraintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columnConstraints
}

func (*ColumnConstraintsContext) IsColumnConstraintsContext() {}

func NewColumnConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintsContext {
	var p = new(ColumnConstraintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columnConstraints

	return p
}

func (s *ColumnConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintsContext) KEY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEY, 0)
}

func (s *ColumnConstraintsContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIMARY, 0)
}

func (s *ColumnConstraintsContext) HEADERS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHEADERS, 0)
}

func (s *ColumnConstraintsContext) HEADER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHEADER, 0)
}

func (s *ColumnConstraintsContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *ColumnConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnConstraints(s)
	}
}

func (s *ColumnConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnConstraints(s)
	}
}

func (p *SqlBaseParser) ColumnConstraints() (localctx IColumnConstraintsContext) {
	localctx = NewColumnConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SqlBaseParserRULE_columnConstraints)
	var _la int

	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserKEY, SqlBaseParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserPRIMARY {
			{
				p.SetState(568)
				p.Match(SqlBaseParserPRIMARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(571)
			p.Match(SqlBaseParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserHEADERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(572)
			p.Match(SqlBaseParserHEADERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserHEADER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(573)
			p.Match(SqlBaseParserHEADER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(574)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(575)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(576)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePropertiesContext is an interface to support dynamic dispatch.
type ITablePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableProperty() []ITablePropertyContext
	TableProperty(i int) ITablePropertyContext

	// IsTablePropertiesContext differentiates from other interfaces.
	IsTablePropertiesContext()
}

type TablePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesContext() *TablePropertiesContext {
	var p = new(TablePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableProperties
	return p
}

func InitEmptyTablePropertiesContext(p *TablePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableProperties
}

func (*TablePropertiesContext) IsTablePropertiesContext() {}

func NewTablePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesContext {
	var p = new(TablePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableProperties

	return p
}

func (s *TablePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesContext) AllTableProperty() []ITablePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablePropertyContext); ok {
			len++
		}
	}

	tst := make([]ITablePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablePropertyContext); ok {
			tst[i] = t.(ITablePropertyContext)
			i++
		}
	}

	return tst
}

func (s *TablePropertiesContext) TableProperty(i int) ITablePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePropertyContext)
}

func (s *TablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableProperties(s)
	}
}

func (s *TablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableProperties(s)
	}
}

func (p *SqlBaseParser) TableProperties() (localctx ITablePropertiesContext) {
	localctx = NewTablePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SqlBaseParserRULE_tableProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(580)
		p.TableProperty()
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__1 {
		{
			p.SetState(581)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(582)
			p.TableProperty()
		}

		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(588)
		p.Match(SqlBaseParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePropertyContext is an interface to support dynamic dispatch.
type ITablePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	Literal() ILiteralContext
	Identifier() IIdentifierContext
	STRING() antlr.TerminalNode

	// IsTablePropertyContext differentiates from other interfaces.
	IsTablePropertyContext()
}

type TablePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyContext() *TablePropertyContext {
	var p = new(TablePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableProperty
	return p
}

func InitEmptyTablePropertyContext(p *TablePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tableProperty
}

func (*TablePropertyContext) IsTablePropertyContext() {}

func NewTablePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyContext {
	var p = new(TablePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tableProperty

	return p
}

func (s *TablePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *TablePropertyContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *TablePropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablePropertyContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *TablePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableProperty(s)
	}
}

func (s *TablePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableProperty(s)
	}
}

func (p *SqlBaseParser) TableProperty() (localctx ITablePropertyContext) {
	localctx = NewTablePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SqlBaseParserRULE_tableProperty)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__7, SqlBaseParserEMIT, SqlBaseParserCHANGES, SqlBaseParserFINAL, SqlBaseParserESCAPE, SqlBaseParserINTEGER, SqlBaseParserDATE, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserINTERVAL, SqlBaseParserYEAR, SqlBaseParserMONTH, SqlBaseParserDAY, SqlBaseParserHOUR, SqlBaseParserMINUTE, SqlBaseParserSECOND, SqlBaseParserZONE, SqlBaseParserGRACE, SqlBaseParserPERIOD, SqlBaseParserPARTITION, SqlBaseParserSTRUCT, SqlBaseParserEXPLAIN, SqlBaseParserANALYZE, SqlBaseParserTYPE, SqlBaseParserTYPES, SqlBaseParserSHOW, SqlBaseParserTABLES, SqlBaseParserCOLUMNS, SqlBaseParserCOLUMN, SqlBaseParserPARTITIONS, SqlBaseParserFUNCTIONS, SqlBaseParserFUNCTION, SqlBaseParserARRAY, SqlBaseParserMAP, SqlBaseParserSET, SqlBaseParserDEFINE, SqlBaseParserUNDEFINE, SqlBaseParserRESET, SqlBaseParserSESSION, SqlBaseParserKEY, SqlBaseParserSINK, SqlBaseParserSOURCE, SqlBaseParserPRIMARY, SqlBaseParserREPLACE, SqlBaseParserASSERT, SqlBaseParserADD, SqlBaseParserALTER, SqlBaseParserVARIABLES, SqlBaseParserPLUGINS, SqlBaseParserHEADERS, SqlBaseParserHEADER, SqlBaseParserSYSTEM, SqlBaseParserTIMEOUT, SqlBaseParserSCHEMA, SqlBaseParserSUBJECT, SqlBaseParserID, SqlBaseParserIF, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserVARIABLE:
		{
			p.SetState(590)
			p.Identifier()
		}

	case SqlBaseParserSTRING:
		{
			p.SetState(591)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(594)
		p.Match(SqlBaseParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(595)
		p.Literal()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrintClauseContext is an interface to support dynamic dispatch.
type IPrintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	BEGINNING() antlr.TerminalNode
	IntervalClause() IIntervalClauseContext
	LimitClause() ILimitClauseContext

	// IsPrintClauseContext differentiates from other interfaces.
	IsPrintClauseContext()
}

type PrintClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintClauseContext() *PrintClauseContext {
	var p = new(PrintClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_printClause
	return p
}

func InitEmptyPrintClauseContext(p *PrintClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_printClause
}

func (*PrintClauseContext) IsPrintClauseContext() {}

func NewPrintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintClauseContext {
	var p = new(PrintClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_printClause

	return p
}

func (s *PrintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *PrintClauseContext) BEGINNING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBEGINNING, 0)
}

func (s *PrintClauseContext) IntervalClause() IIntervalClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalClauseContext)
}

func (s *PrintClauseContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *PrintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPrintClause(s)
	}
}

func (s *PrintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPrintClause(s)
	}
}

func (p *SqlBaseParser) PrintClause() (localctx IPrintClauseContext) {
	localctx = NewPrintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SqlBaseParserRULE_printClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserFROM {
		{
			p.SetState(597)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(598)
			p.Match(SqlBaseParserBEGINNING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserINTERVAL || _la == SqlBaseParserSAMPLE {
		{
			p.SetState(601)
			p.IntervalClause()
		}

	}
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserLIMIT {
		{
			p.SetState(604)
			p.LimitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalClauseContext is an interface to support dynamic dispatch.
type IIntervalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	INTERVAL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode

	// IsIntervalClauseContext differentiates from other interfaces.
	IsIntervalClauseContext()
}

type IntervalClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalClauseContext() *IntervalClauseContext {
	var p = new(IntervalClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_intervalClause
	return p
}

func InitEmptyIntervalClauseContext(p *IntervalClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_intervalClause
}

func (*IntervalClauseContext) IsIntervalClauseContext() {}

func NewIntervalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalClauseContext {
	var p = new(IntervalClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_intervalClause

	return p
}

func (s *IntervalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalClauseContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *IntervalClauseContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *IntervalClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSAMPLE, 0)
}

func (s *IntervalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntervalClause(s)
	}
}

func (s *IntervalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntervalClause(s)
	}
}

func (p *SqlBaseParser) IntervalClause() (localctx IIntervalClauseContext) {
	localctx = NewIntervalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SqlBaseParserRULE_intervalClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserINTERVAL || _la == SqlBaseParserSAMPLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(608)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	Number() INumberContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIMIT, 0)
}

func (s *LimitClauseContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *SqlBaseParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SqlBaseParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(SqlBaseParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(611)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRetentionClauseContext is an interface to support dynamic dispatch.
type IRetentionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETENTION() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext

	// IsRetentionClauseContext differentiates from other interfaces.
	IsRetentionClauseContext()
}

type RetentionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetentionClauseContext() *RetentionClauseContext {
	var p = new(RetentionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_retentionClause
	return p
}

func InitEmptyRetentionClauseContext(p *RetentionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_retentionClause
}

func (*RetentionClauseContext) IsRetentionClauseContext() {}

func NewRetentionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetentionClauseContext {
	var p = new(RetentionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_retentionClause

	return p
}

func (s *RetentionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RetentionClauseContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRETENTION, 0)
}

func (s *RetentionClauseContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RetentionClauseContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *RetentionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetentionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetentionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRetentionClause(s)
	}
}

func (s *RetentionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRetentionClause(s)
	}
}

func (p *SqlBaseParser) RetentionClause() (localctx IRetentionClauseContext) {
	localctx = NewRetentionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SqlBaseParserRULE_retentionClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(613)
		p.Match(SqlBaseParserRETENTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(614)
		p.Number()
	}
	{
		p.SetState(615)
		p.WindowUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGracePeriodClauseContext is an interface to support dynamic dispatch.
type IGracePeriodClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRACE() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext

	// IsGracePeriodClauseContext differentiates from other interfaces.
	IsGracePeriodClauseContext()
}

type GracePeriodClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGracePeriodClauseContext() *GracePeriodClauseContext {
	var p = new(GracePeriodClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_gracePeriodClause
	return p
}

func InitEmptyGracePeriodClauseContext(p *GracePeriodClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_gracePeriodClause
}

func (*GracePeriodClauseContext) IsGracePeriodClauseContext() {}

func NewGracePeriodClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GracePeriodClauseContext {
	var p = new(GracePeriodClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_gracePeriodClause

	return p
}

func (s *GracePeriodClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GracePeriodClauseContext) GRACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRACE, 0)
}

func (s *GracePeriodClauseContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERIOD, 0)
}

func (s *GracePeriodClauseContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *GracePeriodClauseContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *GracePeriodClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GracePeriodClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GracePeriodClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGracePeriodClause(s)
	}
}

func (s *GracePeriodClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGracePeriodClause(s)
	}
}

func (p *SqlBaseParser) GracePeriodClause() (localctx IGracePeriodClauseContext) {
	localctx = NewGracePeriodClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SqlBaseParserRULE_gracePeriodClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(SqlBaseParserGRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(618)
		p.Match(SqlBaseParserPERIOD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(619)
		p.Number()
	}
	{
		p.SetState(620)
		p.WindowUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowExpressionContext is an interface to support dynamic dispatch.
type IWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TumblingWindowExpression() ITumblingWindowExpressionContext
	HoppingWindowExpression() IHoppingWindowExpressionContext
	SessionWindowExpression() ISessionWindowExpressionContext
	IDENTIFIER() antlr.TerminalNode

	// IsWindowExpressionContext differentiates from other interfaces.
	IsWindowExpressionContext()
}

type WindowExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowExpressionContext() *WindowExpressionContext {
	var p = new(WindowExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowExpression
	return p
}

func InitEmptyWindowExpressionContext(p *WindowExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowExpression
}

func (*WindowExpressionContext) IsWindowExpressionContext() {}

func NewWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowExpressionContext {
	var p = new(WindowExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_windowExpression

	return p
}

func (s *WindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowExpressionContext) TumblingWindowExpression() ITumblingWindowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITumblingWindowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITumblingWindowExpressionContext)
}

func (s *WindowExpressionContext) HoppingWindowExpression() IHoppingWindowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHoppingWindowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHoppingWindowExpressionContext)
}

func (s *WindowExpressionContext) SessionWindowExpression() ISessionWindowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionWindowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionWindowExpressionContext)
}

func (s *WindowExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER, 0)
}

func (s *WindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWindowExpression(s)
	}
}

func (s *WindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWindowExpression(s)
	}
}

func (p *SqlBaseParser) WindowExpression() (localctx IWindowExpressionContext) {
	localctx = NewWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SqlBaseParserRULE_windowExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(623)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserIDENTIFIER {
		{
			p.SetState(622)
			p.Match(SqlBaseParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserTUMBLING:
		{
			p.SetState(625)
			p.TumblingWindowExpression()
		}

	case SqlBaseParserHOPPING:
		{
			p.SetState(626)
			p.HoppingWindowExpression()
		}

	case SqlBaseParserSESSION:
		{
			p.SetState(627)
			p.SessionWindowExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITumblingWindowExpressionContext is an interface to support dynamic dispatch.
type ITumblingWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TUMBLING() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext
	RetentionClause() IRetentionClauseContext
	GracePeriodClause() IGracePeriodClauseContext

	// IsTumblingWindowExpressionContext differentiates from other interfaces.
	IsTumblingWindowExpressionContext()
}

type TumblingWindowExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTumblingWindowExpressionContext() *TumblingWindowExpressionContext {
	var p = new(TumblingWindowExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tumblingWindowExpression
	return p
}

func InitEmptyTumblingWindowExpressionContext(p *TumblingWindowExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_tumblingWindowExpression
}

func (*TumblingWindowExpressionContext) IsTumblingWindowExpressionContext() {}

func NewTumblingWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TumblingWindowExpressionContext {
	var p = new(TumblingWindowExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_tumblingWindowExpression

	return p
}

func (s *TumblingWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TumblingWindowExpressionContext) TUMBLING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTUMBLING, 0)
}

func (s *TumblingWindowExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSIZE, 0)
}

func (s *TumblingWindowExpressionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *TumblingWindowExpressionContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *TumblingWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetentionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *TumblingWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *TumblingWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TumblingWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TumblingWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTumblingWindowExpression(s)
	}
}

func (s *TumblingWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTumblingWindowExpression(s)
	}
}

func (p *SqlBaseParser) TumblingWindowExpression() (localctx ITumblingWindowExpressionContext) {
	localctx = NewTumblingWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SqlBaseParserRULE_tumblingWindowExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(630)
		p.Match(SqlBaseParserTUMBLING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(631)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(632)
		p.Match(SqlBaseParserSIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(633)
		p.Number()
	}
	{
		p.SetState(634)
		p.WindowUnit()
	}
	p.SetState(637)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(635)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(636)
			p.RetentionClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserT__1 {
		{
			p.SetState(639)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(640)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(643)
		p.Match(SqlBaseParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHoppingWindowExpressionContext is an interface to support dynamic dispatch.
type IHoppingWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HOPPING() antlr.TerminalNode
	SIZE() antlr.TerminalNode
	AllNumber() []INumberContext
	Number(i int) INumberContext
	AllWindowUnit() []IWindowUnitContext
	WindowUnit(i int) IWindowUnitContext
	ADVANCE() antlr.TerminalNode
	BY() antlr.TerminalNode
	RetentionClause() IRetentionClauseContext
	GracePeriodClause() IGracePeriodClauseContext

	// IsHoppingWindowExpressionContext differentiates from other interfaces.
	IsHoppingWindowExpressionContext()
}

type HoppingWindowExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHoppingWindowExpressionContext() *HoppingWindowExpressionContext {
	var p = new(HoppingWindowExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_hoppingWindowExpression
	return p
}

func InitEmptyHoppingWindowExpressionContext(p *HoppingWindowExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_hoppingWindowExpression
}

func (*HoppingWindowExpressionContext) IsHoppingWindowExpressionContext() {}

func NewHoppingWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HoppingWindowExpressionContext {
	var p = new(HoppingWindowExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_hoppingWindowExpression

	return p
}

func (s *HoppingWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *HoppingWindowExpressionContext) HOPPING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOPPING, 0)
}

func (s *HoppingWindowExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSIZE, 0)
}

func (s *HoppingWindowExpressionContext) AllNumber() []INumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberContext); ok {
			len++
		}
	}

	tst := make([]INumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberContext); ok {
			tst[i] = t.(INumberContext)
			i++
		}
	}

	return tst
}

func (s *HoppingWindowExpressionContext) Number(i int) INumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *HoppingWindowExpressionContext) AllWindowUnit() []IWindowUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowUnitContext); ok {
			len++
		}
	}

	tst := make([]IWindowUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowUnitContext); ok {
			tst[i] = t.(IWindowUnitContext)
			i++
		}
	}

	return tst
}

func (s *HoppingWindowExpressionContext) WindowUnit(i int) IWindowUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *HoppingWindowExpressionContext) ADVANCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADVANCE, 0)
}

func (s *HoppingWindowExpressionContext) BY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBY, 0)
}

func (s *HoppingWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetentionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *HoppingWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *HoppingWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HoppingWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HoppingWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterHoppingWindowExpression(s)
	}
}

func (s *HoppingWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitHoppingWindowExpression(s)
	}
}

func (p *SqlBaseParser) HoppingWindowExpression() (localctx IHoppingWindowExpressionContext) {
	localctx = NewHoppingWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SqlBaseParserRULE_hoppingWindowExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Match(SqlBaseParserHOPPING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(646)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(647)
		p.Match(SqlBaseParserSIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(648)
		p.Number()
	}
	{
		p.SetState(649)
		p.WindowUnit()
	}
	{
		p.SetState(650)
		p.Match(SqlBaseParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(651)
		p.Match(SqlBaseParserADVANCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(652)
		p.Match(SqlBaseParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.Number()
	}
	{
		p.SetState(654)
		p.WindowUnit()
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(655)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(656)
			p.RetentionClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserT__1 {
		{
			p.SetState(659)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(660)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(663)
		p.Match(SqlBaseParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionWindowExpressionContext is an interface to support dynamic dispatch.
type ISessionWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SESSION() antlr.TerminalNode
	Number() INumberContext
	WindowUnit() IWindowUnitContext
	RetentionClause() IRetentionClauseContext
	GracePeriodClause() IGracePeriodClauseContext

	// IsSessionWindowExpressionContext differentiates from other interfaces.
	IsSessionWindowExpressionContext()
}

type SessionWindowExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionWindowExpressionContext() *SessionWindowExpressionContext {
	var p = new(SessionWindowExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sessionWindowExpression
	return p
}

func InitEmptySessionWindowExpressionContext(p *SessionWindowExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sessionWindowExpression
}

func (*SessionWindowExpressionContext) IsSessionWindowExpressionContext() {}

func NewSessionWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionWindowExpressionContext {
	var p = new(SessionWindowExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sessionWindowExpression

	return p
}

func (s *SessionWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionWindowExpressionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *SessionWindowExpressionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SessionWindowExpressionContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *SessionWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetentionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *SessionWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *SessionWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSessionWindowExpression(s)
	}
}

func (s *SessionWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSessionWindowExpression(s)
	}
}

func (p *SqlBaseParser) SessionWindowExpression() (localctx ISessionWindowExpressionContext) {
	localctx = NewSessionWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SqlBaseParserRULE_sessionWindowExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(665)
		p.Match(SqlBaseParserSESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(666)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(667)
		p.Number()
	}
	{
		p.SetState(668)
		p.WindowUnit()
	}
	p.SetState(671)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(669)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(670)
			p.RetentionClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserT__1 {
		{
			p.SetState(673)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(677)
		p.Match(SqlBaseParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowUnitContext is an interface to support dynamic dispatch.
type IWindowUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	SECONDS() antlr.TerminalNode
	MILLISECONDS() antlr.TerminalNode

	// IsWindowUnitContext differentiates from other interfaces.
	IsWindowUnitContext()
}

type WindowUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowUnitContext() *WindowUnitContext {
	var p = new(WindowUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowUnit
	return p
}

func InitEmptyWindowUnitContext(p *WindowUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_windowUnit
}

func (*WindowUnitContext) IsWindowUnitContext() {}

func NewWindowUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowUnitContext {
	var p = new(WindowUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_windowUnit

	return p
}

func (s *WindowUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowUnitContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *WindowUnitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *WindowUnitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *WindowUnitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *WindowUnitContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECOND, 0)
}

func (s *WindowUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAYS, 0)
}

func (s *WindowUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOURS, 0)
}

func (s *WindowUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTES, 0)
}

func (s *WindowUnitContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECONDS, 0)
}

func (s *WindowUnitContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMILLISECONDS, 0)
}

func (s *WindowUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWindowUnit(s)
	}
}

func (s *WindowUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWindowUnit(s)
	}
}

func (p *SqlBaseParser) WindowUnit() (localctx IWindowUnitContext) {
	localctx = NewWindowUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SqlBaseParserRULE_windowUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&70351151991619584) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupBy
	return p
}

func InitEmptyGroupByContext(p *GroupByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_groupBy
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupByContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (p *SqlBaseParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SqlBaseParserRULE_groupBy)
	var _la int

	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.valueExpression(0)
		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__1 {
			{
				p.SetState(682)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(683)
				p.valueExpression(0)
			}

			p.SetState(688)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(689)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539346962297647352) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&143125653246455809) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140464229449497) != 0) {
			{
				p.SetState(690)
				p.valueExpression(0)
			}
			p.SetState(695)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__1 {
				{
					p.SetState(691)
					p.Match(SqlBaseParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(692)
					p.valueExpression(0)
				}

				p.SetState(697)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(700)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionByContext is an interface to support dynamic dispatch.
type IPartitionByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext

	// IsPartitionByContext differentiates from other interfaces.
	IsPartitionByContext()
}

type PartitionByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByContext() *PartitionByContext {
	var p = new(PartitionByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionBy
	return p
}

func InitEmptyPartitionByContext(p *PartitionByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_partitionBy
}

func (*PartitionByContext) IsPartitionByContext() {}

func NewPartitionByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByContext {
	var p = new(PartitionByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_partitionBy

	return p
}

func (s *PartitionByContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionByContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PartitionByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPartitionBy(s)
	}
}

func (s *PartitionByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPartitionBy(s)
	}
}

func (p *SqlBaseParser) PartitionBy() (localctx IPartitionByContext) {
	localctx = NewPartitionByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SqlBaseParserRULE_partitionBy)
	var _la int

	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(703)
			p.valueExpression(0)
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__1 {
			{
				p.SetState(704)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(705)
				p.valueExpression(0)
			}

			p.SetState(710)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(711)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539346962297647352) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&143125653246455809) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140464229449497) != 0) {
			{
				p.SetState(712)
				p.valueExpression(0)
			}
			p.SetState(717)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__1 {
				{
					p.SetState(713)
					p.Match(SqlBaseParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(714)
					p.valueExpression(0)
				}

				p.SetState(719)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(722)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesContext is an interface to support dynamic dispatch.
type IValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext

	// IsValuesContext differentiates from other interfaces.
	IsValuesContext()
}

type ValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesContext() *ValuesContext {
	var p = new(ValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_values
	return p
}

func InitEmptyValuesContext(p *ValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_values
}

func (*ValuesContext) IsValuesContext() {}

func NewValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesContext {
	var p = new(ValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_values

	return p
}

func (s *ValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ValuesContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterValues(s)
	}
}

func (s *ValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitValues(s)
	}
}

func (p *SqlBaseParser) Values() (localctx IValuesContext) {
	localctx = NewValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SqlBaseParserRULE_values)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539346962297647352) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&143125653246455809) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140464229449497) != 0) {
		{
			p.SetState(726)
			p.valueExpression(0)
		}
		p.SetState(731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__1 {
			{
				p.SetState(727)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(728)
				p.valueExpression(0)
			}

			p.SetState(733)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(736)
		p.Match(SqlBaseParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyAll(ctx *SelectItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

type SelectSingleContext struct {
	SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

type SelectStructAllContext struct {
	SelectItemContext
	base IPrimaryExpressionContext
}

func NewSelectStructAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectStructAllContext {
	var p = new(SelectStructAllContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectStructAllContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *SelectStructAllContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *SelectStructAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStructAllContext) STRUCT_FIELD_REF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT_FIELD_REF, 0)
}

func (s *SelectStructAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *SelectStructAllContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SelectStructAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSelectStructAll(s)
	}
}

func (s *SelectStructAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSelectStructAll(s)
	}
}

func (p *SqlBaseParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SqlBaseParserRULE_selectItem)
	var _la int

	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(738)
			p.Expression()
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539347082556715264) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&-4161291112904425469) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&133143994367) != 0) {
			p.SetState(740)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == SqlBaseParserAS {
				{
					p.SetState(739)
					p.Match(SqlBaseParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(742)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectStructAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(745)

			var _x = p.primaryExpression(0)

			localctx.(*SelectStructAllContext).base = _x
		}
		{
			p.SetState(746)
			p.Match(SqlBaseParserSTRUCT_FIELD_REF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(749)
			p.Identifier()
		}
		{
			p.SetState(750)
			p.Match(SqlBaseParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(751)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(753)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyAll(ctx *RelationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) AliasedRelation() IAliasedRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

type JoinRelationContext struct {
	RelationContext
	left IAliasedRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	InitEmptyRelationContext(&p.RelationContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IAliasedRelationContext { return s.left }

func (s *JoinRelationContext) SetLeft(v IAliasedRelationContext) { s.left = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AliasedRelation() IAliasedRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *JoinRelationContext) AllJoinedSource() []IJoinedSourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinedSourceContext); ok {
			len++
		}
	}

	tst := make([]IJoinedSourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinedSourceContext); ok {
			tst[i] = t.(IJoinedSourceContext)
			i++
		}
	}

	return tst
}

func (s *JoinRelationContext) JoinedSource(i int) IJoinedSourceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinedSourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinedSourceContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *SqlBaseParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SqlBaseParserRULE_relation)
	var _la int

	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(756)

			var _x = p.AliasedRelation()

			localctx.(*JoinRelationContext).left = _x
		}
		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&59) != 0) {
			{
				p.SetState(757)
				p.JoinedSource()
			}

			p.SetState(760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewRelationDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(762)
			p.AliasedRelation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinedSourceContext is an interface to support dynamic dispatch.
type IJoinedSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JoinType() IJoinTypeContext
	JOIN() antlr.TerminalNode
	AliasedRelation() IAliasedRelationContext
	JoinCriteria() IJoinCriteriaContext
	JoinWindow() IJoinWindowContext

	// IsJoinedSourceContext differentiates from other interfaces.
	IsJoinedSourceContext()
}

type JoinedSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinedSourceContext() *JoinedSourceContext {
	var p = new(JoinedSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinedSource
	return p
}

func InitEmptyJoinedSourceContext(p *JoinedSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinedSource
}

func (*JoinedSourceContext) IsJoinedSourceContext() {}

func NewJoinedSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinedSourceContext {
	var p = new(JoinedSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinedSource

	return p
}

func (s *JoinedSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinedSourceContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinedSourceContext) JOIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserJOIN, 0)
}

func (s *JoinedSourceContext) AliasedRelation() IAliasedRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *JoinedSourceContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinedSourceContext) JoinWindow() IJoinWindowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinWindowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinWindowContext)
}

func (s *JoinedSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinedSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinedSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinedSource(s)
	}
}

func (s *JoinedSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinedSource(s)
	}
}

func (p *SqlBaseParser) JoinedSource() (localctx IJoinedSourceContext) {
	localctx = NewJoinedSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, SqlBaseParserRULE_joinedSource)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.JoinType()
	}
	{
		p.SetState(766)
		p.Match(SqlBaseParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(767)
		p.AliasedRelation()
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SqlBaseParserWITHIN {
		{
			p.SetState(768)
			p.JoinWindow()
		}

	}
	{
		p.SetState(771)
		p.JoinCriteria()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) CopyAll(ctx *JoinTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RightJoinContext struct {
	JoinTypeContext
}

func NewRightJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RightJoinContext {
	var p = new(RightJoinContext)

	InitEmptyJoinTypeContext(&p.JoinTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinTypeContext))

	return p
}

func (s *RightJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RightJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRIGHT, 0)
}

func (s *RightJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *RightJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterRightJoin(s)
	}
}

func (s *RightJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitRightJoin(s)
	}
}

type InnerJoinContext struct {
	JoinTypeContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	InitEmptyJoinTypeContext(&p.JoinTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinTypeContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINNER, 0)
}

func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

type LeftJoinContext struct {
	JoinTypeContext
}

func NewLeftJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LeftJoinContext {
	var p = new(LeftJoinContext)

	InitEmptyJoinTypeContext(&p.JoinTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinTypeContext))

	return p
}

func (s *LeftJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLEFT, 0)
}

func (s *LeftJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *LeftJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLeftJoin(s)
	}
}

func (s *LeftJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLeftJoin(s)
	}
}

type OuterJoinContext struct {
	JoinTypeContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	InitEmptyJoinTypeContext(&p.JoinTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*JoinTypeContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) FULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFULL, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOUTER, 0)
}

func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

func (p *SqlBaseParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SqlBaseParserRULE_joinType)
	var _la int

	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserJOIN, SqlBaseParserINNER:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserINNER {
			{
				p.SetState(773)
				p.Match(SqlBaseParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SqlBaseParserFULL:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(776)
			p.Match(SqlBaseParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(777)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SqlBaseParserLEFT:
		localctx = NewLeftJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(780)
			p.Match(SqlBaseParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(781)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case SqlBaseParserRIGHT:
		localctx = NewRightJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(784)
			p.Match(SqlBaseParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserOUTER {
			{
				p.SetState(785)
				p.Match(SqlBaseParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinWindowContext is an interface to support dynamic dispatch.
type IJoinWindowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITHIN() antlr.TerminalNode
	WithinExpression() IWithinExpressionContext

	// IsJoinWindowContext differentiates from other interfaces.
	IsJoinWindowContext()
}

type JoinWindowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinWindowContext() *JoinWindowContext {
	var p = new(JoinWindowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinWindow
	return p
}

func InitEmptyJoinWindowContext(p *JoinWindowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinWindow
}

func (*JoinWindowContext) IsJoinWindowContext() {}

func NewJoinWindowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinWindowContext {
	var p = new(JoinWindowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinWindow

	return p
}

func (s *JoinWindowContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinWindowContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWITHIN, 0)
}

func (s *JoinWindowContext) WithinExpression() IWithinExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithinExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithinExpressionContext)
}

func (s *JoinWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinWindow(s)
	}
}

func (s *JoinWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinWindow(s)
	}
}

func (p *SqlBaseParser) JoinWindow() (localctx IJoinWindowContext) {
	localctx = NewJoinWindowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SqlBaseParserRULE_joinWindow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)
		p.Match(SqlBaseParserWITHIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(791)
		p.WithinExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithinExpressionContext is an interface to support dynamic dispatch.
type IWithinExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWithinExpressionContext differentiates from other interfaces.
	IsWithinExpressionContext()
}

type WithinExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithinExpressionContext() *WithinExpressionContext {
	var p = new(WithinExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_withinExpression
	return p
}

func InitEmptyWithinExpressionContext(p *WithinExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_withinExpression
}

func (*WithinExpressionContext) IsWithinExpressionContext() {}

func NewWithinExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithinExpressionContext {
	var p = new(WithinExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_withinExpression

	return p
}

func (s *WithinExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithinExpressionContext) CopyAll(ctx *WithinExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *WithinExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithinExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SingleJoinWindowContext struct {
	WithinExpressionContext
}

func NewSingleJoinWindowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleJoinWindowContext {
	var p = new(SingleJoinWindowContext)

	InitEmptyWithinExpressionContext(&p.WithinExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*WithinExpressionContext))

	return p
}

func (s *SingleJoinWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleJoinWindowContext) JoinWindowSize() IJoinWindowSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinWindowSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinWindowSizeContext)
}

func (s *SingleJoinWindowContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *SingleJoinWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSingleJoinWindow(s)
	}
}

func (s *SingleJoinWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSingleJoinWindow(s)
	}
}

type JoinWindowWithBeforeAndAfterContext struct {
	WithinExpressionContext
}

func NewJoinWindowWithBeforeAndAfterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinWindowWithBeforeAndAfterContext {
	var p = new(JoinWindowWithBeforeAndAfterContext)

	InitEmptyWithinExpressionContext(&p.WithinExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*WithinExpressionContext))

	return p
}

func (s *JoinWindowWithBeforeAndAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowWithBeforeAndAfterContext) AllJoinWindowSize() []IJoinWindowSizeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinWindowSizeContext); ok {
			len++
		}
	}

	tst := make([]IJoinWindowSizeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinWindowSizeContext); ok {
			tst[i] = t.(IJoinWindowSizeContext)
			i++
		}
	}

	return tst
}

func (s *JoinWindowWithBeforeAndAfterContext) JoinWindowSize(i int) IJoinWindowSizeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinWindowSizeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinWindowSizeContext)
}

func (s *JoinWindowWithBeforeAndAfterContext) GracePeriodClause() IGracePeriodClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGracePeriodClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *JoinWindowWithBeforeAndAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinWindowWithBeforeAndAfter(s)
	}
}

func (s *JoinWindowWithBeforeAndAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinWindowWithBeforeAndAfter(s)
	}
}

func (p *SqlBaseParser) WithinExpression() (localctx IWithinExpressionContext) {
	localctx = NewWithinExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SqlBaseParserRULE_withinExpression)
	var _la int

	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__2:
		localctx = NewJoinWindowWithBeforeAndAfterContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(793)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(794)
			p.JoinWindowSize()
		}
		{
			p.SetState(795)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(796)
			p.JoinWindowSize()
		}
		{
			p.SetState(797)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserGRACE {
			{
				p.SetState(798)
				p.GracePeriodClause()
			}

		}

	case SqlBaseParserMINUS, SqlBaseParserINTEGER_VALUE, SqlBaseParserDECIMAL_VALUE, SqlBaseParserFLOATING_POINT_VALUE:
		localctx = NewSingleJoinWindowContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(801)
			p.JoinWindowSize()
		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserGRACE {
			{
				p.SetState(802)
				p.GracePeriodClause()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinWindowSizeContext is an interface to support dynamic dispatch.
type IJoinWindowSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	WindowUnit() IWindowUnitContext

	// IsJoinWindowSizeContext differentiates from other interfaces.
	IsJoinWindowSizeContext()
}

type JoinWindowSizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinWindowSizeContext() *JoinWindowSizeContext {
	var p = new(JoinWindowSizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinWindowSize
	return p
}

func InitEmptyJoinWindowSizeContext(p *JoinWindowSizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinWindowSize
}

func (*JoinWindowSizeContext) IsJoinWindowSizeContext() {}

func NewJoinWindowSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinWindowSizeContext {
	var p = new(JoinWindowSizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinWindowSize

	return p
}

func (s *JoinWindowSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinWindowSizeContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *JoinWindowSizeContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *JoinWindowSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinWindowSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinWindowSize(s)
	}
}

func (s *JoinWindowSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinWindowSize(s)
	}
}

func (p *SqlBaseParser) JoinWindowSize() (localctx IJoinWindowSizeContext) {
	localctx = NewJoinWindowSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SqlBaseParserRULE_joinWindowSize)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(807)
		p.Number()
	}
	{
		p.SetState(808)
		p.WindowUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *SqlBaseParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SqlBaseParserRULE_joinCriteria)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.Match(SqlBaseParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(811)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	SourceName() ISourceNameContext
	AS() antlr.TerminalNode

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation
	return p
}

func InitEmptyAliasedRelationContext(p *AliasedRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (p *SqlBaseParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SqlBaseParserRULE_aliasedRelation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		p.RelationPrimary()
	}
	p.SetState(818)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserAS {
			{
				p.SetState(814)
				p.Match(SqlBaseParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(817)
			p.SourceName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnsContext is an interface to support dynamic dispatch.
type IColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnsContext differentiates from other interfaces.
	IsColumnsContext()
}

type ColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsContext() *ColumnsContext {
	var p = new(ColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columns
	return p
}

func InitEmptyColumnsContext(p *ColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_columns
}

func (*ColumnsContext) IsColumnsContext() {}

func NewColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsContext {
	var p = new(ColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_columns

	return p
}

func (s *ColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnsContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumns(s)
	}
}

func (s *ColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumns(s)
	}
}

func (p *SqlBaseParser) Columns() (localctx IColumnsContext) {
	localctx = NewColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SqlBaseParserRULE_columns)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Match(SqlBaseParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(821)
		p.Identifier()
	}
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == SqlBaseParserT__1 {
		{
			p.SetState(822)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(823)
			p.Identifier()
		}

		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(829)
		p.Match(SqlBaseParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableNameContext struct {
	RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) SourceName() ISourceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *SqlBaseParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SqlBaseParserRULE_relationPrimary)
	localctx = NewTableNameContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(831)
		p.SourceName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *SqlBaseParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SqlBaseParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type BooleanDefaultContext struct {
	BooleanExpressionContext
}

func NewBooleanDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanDefaultContext {
	var p = new(BooleanDefaultContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanDefaultContext) Predicated() IPredicatedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicatedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicatedContext)
}

func (s *BooleanDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanDefault(s)
	}
}

func (s *BooleanDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanDefault(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *SqlBaseParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *SqlBaseParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 84
	p.EnterRecursionRule(localctx, 84, SqlBaseParserRULE_booleanExpression, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__2, SqlBaseParserT__7, SqlBaseParserEMIT, SqlBaseParserCHANGES, SqlBaseParserFINAL, SqlBaseParserESCAPE, SqlBaseParserNULL, SqlBaseParserTRUE, SqlBaseParserFALSE, SqlBaseParserINTEGER, SqlBaseParserDATE, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserINTERVAL, SqlBaseParserYEAR, SqlBaseParserMONTH, SqlBaseParserDAY, SqlBaseParserHOUR, SqlBaseParserMINUTE, SqlBaseParserSECOND, SqlBaseParserZONE, SqlBaseParserGRACE, SqlBaseParserPERIOD, SqlBaseParserCASE, SqlBaseParserPARTITION, SqlBaseParserSTRUCT, SqlBaseParserEXPLAIN, SqlBaseParserANALYZE, SqlBaseParserTYPE, SqlBaseParserTYPES, SqlBaseParserCAST, SqlBaseParserSHOW, SqlBaseParserTABLES, SqlBaseParserCOLUMNS, SqlBaseParserCOLUMN, SqlBaseParserPARTITIONS, SqlBaseParserFUNCTIONS, SqlBaseParserFUNCTION, SqlBaseParserARRAY, SqlBaseParserMAP, SqlBaseParserSET, SqlBaseParserDEFINE, SqlBaseParserUNDEFINE, SqlBaseParserRESET, SqlBaseParserSESSION, SqlBaseParserKEY, SqlBaseParserSINK, SqlBaseParserSOURCE, SqlBaseParserPRIMARY, SqlBaseParserREPLACE, SqlBaseParserASSERT, SqlBaseParserADD, SqlBaseParserALTER, SqlBaseParserVARIABLES, SqlBaseParserPLUGINS, SqlBaseParserHEADERS, SqlBaseParserHEADER, SqlBaseParserSYSTEM, SqlBaseParserTIMEOUT, SqlBaseParserSCHEMA, SqlBaseParserSUBJECT, SqlBaseParserID, SqlBaseParserIF, SqlBaseParserPLUS, SqlBaseParserMINUS, SqlBaseParserSTRING, SqlBaseParserINTEGER_VALUE, SqlBaseParserDECIMAL_VALUE, SqlBaseParserFLOATING_POINT_VALUE, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserVARIABLE:
		localctx = NewBooleanDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(836)
			p.Predicated()
		}

	case SqlBaseParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(837)
			p.Match(SqlBaseParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(838)
			p.booleanExpression(3)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(847)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(841)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(842)

					var _m = p.Match(SqlBaseParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(843)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_booleanExpression)
				p.SetState(844)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(845)

					var _m = p.Match(SqlBaseParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(846)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicatedContext is an interface to support dynamic dispatch.
type IPredicatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// Getter signatures
	ValueExpression() IValueExpressionContext
	Predicate() IPredicateContext

	// IsPredicatedContext differentiates from other interfaces.
	IsPredicatedContext()
}

type PredicatedContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicatedContext() *PredicatedContext {
	var p = new(PredicatedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicated
	return p
}

func InitEmptyPredicatedContext(p *PredicatedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicated
}

func (*PredicatedContext) IsPredicatedContext() {}

func NewPredicatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicatedContext {
	var p = new(PredicatedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_predicated

	return p
}

func (s *PredicatedContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicatedContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicatedContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitPredicated(s)
	}
}

func (p *SqlBaseParser) Predicated() (localctx IPredicatedContext) {
	localctx = NewPredicatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SqlBaseParserRULE_predicated)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)

		var _x = p.valueExpression(0)

		localctx.(*PredicatedContext)._valueExpression = _x
	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(853)
			p.Predicate(localctx.(*PredicatedContext).Get_valueExpression())
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() antlr.ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(antlr.ParserRuleContext)

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.ParserRuleContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value antlr.ParserRuleContext) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_predicate

	p.value = value

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetValue() antlr.ParserRuleContext { return s.value }

func (s *PredicateContext) SetValue(v antlr.ParserRuleContext) { s.value = v }

func (s *PredicateContext) CopyAll(ctx *PredicateContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparison(s)
	}
}

type LikeContext struct {
	PredicateContext
	pattern IValueExpressionContext
	escape  antlr.Token
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetEscape() antlr.Token { return s.escape }

func (s *LikeContext) SetEscape(v antlr.Token) { s.escape = v }

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLIKE, 0)
}

func (s *LikeContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *LikeContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLike(s)
	}
}

type DistinctFromContext struct {
	PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

type InListContext struct {
	PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitInList(s)
	}
}

type NullPredicateContext struct {
	PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

type BetweenContext struct {
	PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	InitEmptyPredicateContext(&p.PredicateContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (p *SqlBaseParser) Predicate(value antlr.ParserRuleContext) (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 88, SqlBaseParserRULE_predicate)
	var _la int

	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(856)
			p.ComparisonOperator()
		}
		{
			p.SetState(857)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(859)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(862)
			p.Match(SqlBaseParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(863)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(864)
			p.Match(SqlBaseParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(865)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 3:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(868)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(867)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(870)
			p.Match(SqlBaseParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(871)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(872)
			p.Expression()
		}
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__1 {
			{
				p.SetState(873)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(874)
				p.Expression()
			}

			p.SetState(879)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(880)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(882)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(885)
			p.Match(SqlBaseParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(886)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(887)
				p.Match(SqlBaseParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(888)

				var _m = p.Match(SqlBaseParserSTRING)

				localctx.(*LikeContext).escape = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(891)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(892)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(895)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(896)
			p.Match(SqlBaseParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserNOT {
			{
				p.SetState(897)
				p.Match(SqlBaseParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(900)
			p.Match(SqlBaseParserDISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(901)
			p.Match(SqlBaseParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(902)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ConcatenationContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

type AtTimeZoneContext struct {
	ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeZoneSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (p *SqlBaseParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *SqlBaseParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 90
	p.EnterRecursionRule(localctx, 90, SqlBaseParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(909)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(906)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(907)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(908)
			p.valueExpression(4)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(923)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(911)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(912)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-161)) & ^0x3f) == 0 && ((int64(1)<<(_la-161))&7) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(913)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(914)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(915)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SqlBaseParserPLUS || _la == SqlBaseParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(916)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(917)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(918)
					p.Match(SqlBaseParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(919)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_valueExpression)
				p.SetState(920)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(921)
					p.Match(SqlBaseParserAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(922)
					p.TimeZoneSpecifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) STRUCT_FIELD_REF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT_FIELD_REF, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDereference(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type SubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type StructConstructorContext struct {
	PrimaryExpressionContext
}

func NewStructConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructConstructorContext {
	var p = new(StructConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StructConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructConstructorContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT, 0)
}

func (s *StructConstructorContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *StructConstructorContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructConstructorContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserASSIGN)
}

func (s *StructConstructorContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSIGN, i)
}

func (s *StructConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *StructConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StructConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStructConstructor(s)
	}
}

func (s *StructConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStructConstructor(s)
	}
}

type TypeConstructorContext struct {
	PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type QualifiedColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewQualifiedColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedColumnReferenceContext {
	var p = new(QualifiedColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *QualifiedColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedColumnReferenceContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedColumnReferenceContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQualifiedColumnReference(s)
	}
}

func (s *QualifiedColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQualifiedColumnReference(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserAS, 0)
}

func (s *CastContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitCast(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type ArrayConstructorContext struct {
	PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

type MapConstructorContext struct {
	PrimaryExpressionContext
}

func NewMapConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapConstructorContext {
	var p = new(MapConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *MapConstructorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapConstructorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapConstructorContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(SqlBaseParserASSIGN)
}

func (s *MapConstructorContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSIGN, i)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASTERISK, 0)
}

func (s *FunctionCallContext) AllFunctionArgument() []IFunctionArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			len++
		}
	}

	tst := make([]IFunctionArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionArgumentContext); ok {
			tst[i] = t.(IFunctionArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) FunctionArgument(i int) IFunctionArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *FunctionCallContext) AllLambdaFunction() []ILambdaFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILambdaFunctionContext); ok {
			len++
		}
	}

	tst := make([]ILambdaFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILambdaFunctionContext); ok {
			tst[i] = t.(ILambdaFunctionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) LambdaFunction(i int) ILambdaFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type LiteralExpressionContext struct {
	PrimaryExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (p *SqlBaseParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *SqlBaseParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 92
	p.EnterRecursionRule(localctx, 92, SqlBaseParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(929)
			p.Literal()
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(930)
			p.Identifier()
		}
		{
			p.SetState(931)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(933)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(934)
			p.valueExpression(0)
		}
		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(935)
				p.WhenClause()
			}

			p.SetState(938)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(940)
				p.Match(SqlBaseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(941)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(944)
			p.Match(SqlBaseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(946)
			p.Match(SqlBaseParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == SqlBaseParserWHEN {
			{
				p.SetState(947)
				p.WhenClause()
			}

			p.SetState(950)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserELSE {
			{
				p.SetState(952)
				p.Match(SqlBaseParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(953)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(956)
			p.Match(SqlBaseParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(958)
			p.Match(SqlBaseParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(960)
			p.Expression()
		}
		{
			p.SetState(961)
			p.Match(SqlBaseParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(962)
			p.type_(0)
		}
		{
			p.SetState(963)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(965)
			p.Match(SqlBaseParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(966)
			p.Match(SqlBaseParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539346962029211896) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&143125653246455809) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140464229449497) != 0) {
			{
				p.SetState(967)
				p.Expression()
			}
			p.SetState(972)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__1 {
				{
					p.SetState(968)
					p.Match(SqlBaseParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(969)
					p.Expression()
				}

				p.SetState(974)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(977)
			p.Match(SqlBaseParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(978)
			p.Match(SqlBaseParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(979)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539346962029211896) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&143125653246455809) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140464229449497) != 0) {
			{
				p.SetState(980)
				p.Expression()
			}
			{
				p.SetState(981)
				p.Match(SqlBaseParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(982)
				p.Expression()
			}
			p.SetState(990)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__1 {
				{
					p.SetState(983)
					p.Match(SqlBaseParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(984)
					p.Expression()
				}
				{
					p.SetState(985)
					p.Match(SqlBaseParserASSIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(986)
					p.Expression()
				}

				p.SetState(992)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(995)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStructConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(996)
			p.Match(SqlBaseParserSTRUCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(997)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1011)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539347082556731648) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&-4161291112904425469) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&133143994367) != 0) {
			{
				p.SetState(998)
				p.Identifier()
			}
			{
				p.SetState(999)
				p.Match(SqlBaseParserASSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1000)
				p.Expression()
			}
			p.SetState(1008)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__1 {
				{
					p.SetState(1001)
					p.Match(SqlBaseParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1002)
					p.Identifier()
				}
				{
					p.SetState(1003)
					p.Match(SqlBaseParserASSIGN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1004)
					p.Expression()
				}

				p.SetState(1010)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1013)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1014)
			p.Identifier()
		}
		{
			p.SetState(1015)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1016)
			p.Match(SqlBaseParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1017)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1019)
			p.Identifier()
		}
		{
			p.SetState(1020)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4469259692828258552) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&143125653246455809) != 0) || ((int64((_la-130)) & ^0x3f) == 0 && ((int64(1)<<(_la-130))&140464229449497) != 0) {
			{
				p.SetState(1021)
				p.FunctionArgument()
			}
			p.SetState(1026)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1022)
						p.Match(SqlBaseParserT__1)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1023)
						p.FunctionArgument()
					}

				}
				p.SetState(1028)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1033)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__1 {
				{
					p.SetState(1029)
					p.Match(SqlBaseParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1030)
					p.LambdaFunction()
				}

				p.SetState(1035)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1038)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1040)
			p.Identifier()
		}

	case 12:
		localctx = NewQualifiedColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1041)
			p.Identifier()
		}
		{
			p.SetState(1042)
			p.Match(SqlBaseParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1043)
			p.Identifier()
		}

	case 13:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1045)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1046)
			p.Expression()
		}
		{
			p.SetState(1047)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1059)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(1051)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(1052)
					p.Match(SqlBaseParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1053)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(1054)
					p.Match(SqlBaseParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_primaryExpression)
				p.SetState(1056)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(1057)
					p.Match(SqlBaseParserSTRUCT_FIELD_REF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1058)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgumentContext is an interface to support dynamic dispatch.
type IFunctionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	WindowUnit() IWindowUnitContext

	// IsFunctionArgumentContext differentiates from other interfaces.
	IsFunctionArgumentContext()
}

type FunctionArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentContext() *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionArgument
	return p
}

func InitEmptyFunctionArgumentContext(p *FunctionArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_functionArgument
}

func (*FunctionArgumentContext) IsFunctionArgumentContext() {}

func NewFunctionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_functionArgument

	return p
}

func (s *FunctionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgumentContext) WindowUnit() IWindowUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *FunctionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFunctionArgument(s)
	}
}

func (s *FunctionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFunctionArgument(s)
	}
}

func (p *SqlBaseParser) FunctionArgument() (localctx IFunctionArgumentContext) {
	localctx = NewFunctionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SqlBaseParserRULE_functionArgument)
	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1064)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1065)
			p.WindowUnit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier
	return p
}

func InitEmptyTimeZoneSpecifierContext(p *TimeZoneSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyAll(ctx *TimeZoneSpecifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneStringContext struct {
	TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	InitEmptyTimeZoneSpecifierContext(&p.TimeZoneSpecifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *TimeZoneStringContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (p *SqlBaseParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SqlBaseParserRULE_timeZoneSpecifier)
	localctx = NewTimeZoneStringContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1068)
		p.Match(SqlBaseParserTIME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1069)
		p.Match(SqlBaseParserZONE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1070)
		p.Match(SqlBaseParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *SqlBaseParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SqlBaseParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1072)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-153)) & ^0x3f) == 0 && ((int64(1)<<(_la-153))&63) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *SqlBaseParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SqlBaseParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserTRUE || _la == SqlBaseParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	GT() antlr.TerminalNode
	MAP() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	DECIMAL() antlr.TerminalNode
	AllNumber() []INumberContext
	Number(i int) INumberContext
	BaseType() IBaseTypeContext
	AllTypeParameter() []ITypeParameterContext
	TypeParameter(i int) ITypeParameterContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *TypeContext) LT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLT, 0)
}

func (s *TypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeContext) GT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGT, 0)
}

func (s *TypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *TypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT, 0)
}

func (s *TypeContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL, 0)
}

func (s *TypeContext) AllNumber() []INumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberContext); ok {
			len++
		}
	}

	tst := make([]INumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberContext); ok {
			tst[i] = t.(INumberContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) Number(i int) INumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *TypeContext) BaseType() IBaseTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *TypeContext) AllTypeParameter() []ITypeParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeParameterContext); ok {
			len++
		}
	}

	tst := make([]ITypeParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeParameterContext); ok {
			tst[i] = t.(ITypeParameterContext)
			i++
		}
	}

	return tst
}

func (s *TypeContext) TypeParameter(i int) ITypeParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitType(s)
	}
}

func (p *SqlBaseParser) Type_() (localctx ITypeContext) {
	return p.type_(0)
}

func (p *SqlBaseParser) type_(_p int) (localctx ITypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewTypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ITypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 102
	p.EnterRecursionRule(localctx, 102, SqlBaseParserRULE_type, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1077)
			p.Match(SqlBaseParserARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1078)
			p.Match(SqlBaseParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1079)
			p.type_(0)
		}
		{
			p.SetState(1080)
			p.Match(SqlBaseParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1082)
			p.Match(SqlBaseParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1083)
			p.Match(SqlBaseParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1084)
			p.type_(0)
		}
		{
			p.SetState(1085)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1086)
			p.type_(0)
		}
		{
			p.SetState(1087)
			p.Match(SqlBaseParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(1089)
			p.Match(SqlBaseParserSTRUCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1090)
			p.Match(SqlBaseParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539347082556731648) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&-4161291112904425469) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&133143994367) != 0) {
			{
				p.SetState(1091)
				p.Identifier()
			}
			{
				p.SetState(1092)
				p.type_(0)
			}
			p.SetState(1099)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__1 {
				{
					p.SetState(1093)
					p.Match(SqlBaseParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1094)
					p.Identifier()
				}
				{
					p.SetState(1095)
					p.type_(0)
				}

				p.SetState(1101)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1104)
			p.Match(SqlBaseParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(1105)
			p.Match(SqlBaseParserDECIMAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1106)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1107)
			p.Number()
		}
		{
			p.SetState(1108)
			p.Match(SqlBaseParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1109)
			p.Number()
		}
		{
			p.SetState(1110)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(1112)
			p.BaseType()
		}
		p.SetState(1124)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1113)
				p.Match(SqlBaseParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1114)
				p.TypeParameter()
			}
			p.SetState(1119)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == SqlBaseParserT__1 {
				{
					p.SetState(1115)
					p.Match(SqlBaseParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1116)
					p.TypeParameter()
				}

				p.SetState(1121)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1122)
				p.Match(SqlBaseParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewTypeContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, SqlBaseParserRULE_type)
			p.SetState(1128)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				goto errorExit
			}
			{
				p.SetState(1129)
				p.Match(SqlBaseParserARRAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *SqlBaseParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SqlBaseParserRULE_typeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		_la = p.GetTokenStream().LA(1)

		if !(_la == SqlBaseParserT__7 || _la == SqlBaseParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_baseType
	return p
}

func InitEmptyBaseTypeContext(p *BaseTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_baseType
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *SqlBaseParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SqlBaseParserRULE_baseType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1137)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *SqlBaseParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, SqlBaseParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1139)
		p.Match(SqlBaseParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1140)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1141)
		p.Match(SqlBaseParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1142)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type VariableIdentifierContext struct {
	IdentifierContext
}

func NewVariableIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableIdentifierContext {
	var p = new(VariableIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *VariableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableIdentifierContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIABLE, 0)
}

func (s *VariableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterVariableIdentifier(s)
	}
}

func (s *VariableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitVariableIdentifier(s)
	}
}

type BackQuotedIdentifierContext struct {
	IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

type QuotedIdentifierAlternativeContext struct {
	IdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type DigitIdentifierContext struct {
	IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

type UnquotedIdentifierContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *SqlBaseParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, SqlBaseParserRULE_identifier)
	p.SetState(1150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserVARIABLE:
		localctx = NewVariableIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1144)
			p.Match(SqlBaseParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1145)
			p.Match(SqlBaseParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1146)
			p.Match(SqlBaseParserQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserT__7, SqlBaseParserEMIT, SqlBaseParserCHANGES, SqlBaseParserFINAL, SqlBaseParserESCAPE, SqlBaseParserINTEGER, SqlBaseParserDATE, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserINTERVAL, SqlBaseParserYEAR, SqlBaseParserMONTH, SqlBaseParserDAY, SqlBaseParserHOUR, SqlBaseParserMINUTE, SqlBaseParserSECOND, SqlBaseParserZONE, SqlBaseParserGRACE, SqlBaseParserPERIOD, SqlBaseParserPARTITION, SqlBaseParserSTRUCT, SqlBaseParserEXPLAIN, SqlBaseParserANALYZE, SqlBaseParserTYPE, SqlBaseParserTYPES, SqlBaseParserSHOW, SqlBaseParserTABLES, SqlBaseParserCOLUMNS, SqlBaseParserCOLUMN, SqlBaseParserPARTITIONS, SqlBaseParserFUNCTIONS, SqlBaseParserFUNCTION, SqlBaseParserARRAY, SqlBaseParserMAP, SqlBaseParserSET, SqlBaseParserDEFINE, SqlBaseParserUNDEFINE, SqlBaseParserRESET, SqlBaseParserSESSION, SqlBaseParserKEY, SqlBaseParserSINK, SqlBaseParserSOURCE, SqlBaseParserPRIMARY, SqlBaseParserREPLACE, SqlBaseParserASSERT, SqlBaseParserADD, SqlBaseParserALTER, SqlBaseParserVARIABLES, SqlBaseParserPLUGINS, SqlBaseParserHEADERS, SqlBaseParserHEADER, SqlBaseParserSYSTEM, SqlBaseParserTIMEOUT, SqlBaseParserSCHEMA, SqlBaseParserSUBJECT, SqlBaseParserID, SqlBaseParserIF:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1147)
			p.NonReserved()
		}

	case SqlBaseParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1148)
			p.Match(SqlBaseParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1149)
			p.Match(SqlBaseParserDIGIT_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaFunctionContext is an interface to support dynamic dispatch.
type ILambdaFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLambdaFunctionContext differentiates from other interfaces.
	IsLambdaFunctionContext()
}

type LambdaFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionContext() *LambdaFunctionContext {
	var p = new(LambdaFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_lambdaFunction
	return p
}

func InitEmptyLambdaFunctionContext(p *LambdaFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_lambdaFunction
}

func (*LambdaFunctionContext) IsLambdaFunctionContext() {}

func NewLambdaFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionContext {
	var p = new(LambdaFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_lambdaFunction

	return p
}

func (s *LambdaFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionContext) CopyAll(ctx *LambdaFunctionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LambdaFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LambdaContext struct {
	LambdaFunctionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	InitEmptyLambdaFunctionContext(&p.LambdaFunctionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LambdaFunctionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) LAMBDA_EXPRESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserLAMBDA_EXPRESSION, 0)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (p *SqlBaseParser) LambdaFunction() (localctx ILambdaFunctionContext) {
	localctx = NewLambdaFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, SqlBaseParserRULE_lambdaFunction)
	var _la int

	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserT__7, SqlBaseParserEMIT, SqlBaseParserCHANGES, SqlBaseParserFINAL, SqlBaseParserESCAPE, SqlBaseParserINTEGER, SqlBaseParserDATE, SqlBaseParserTIME, SqlBaseParserTIMESTAMP, SqlBaseParserINTERVAL, SqlBaseParserYEAR, SqlBaseParserMONTH, SqlBaseParserDAY, SqlBaseParserHOUR, SqlBaseParserMINUTE, SqlBaseParserSECOND, SqlBaseParserZONE, SqlBaseParserGRACE, SqlBaseParserPERIOD, SqlBaseParserPARTITION, SqlBaseParserSTRUCT, SqlBaseParserEXPLAIN, SqlBaseParserANALYZE, SqlBaseParserTYPE, SqlBaseParserTYPES, SqlBaseParserSHOW, SqlBaseParserTABLES, SqlBaseParserCOLUMNS, SqlBaseParserCOLUMN, SqlBaseParserPARTITIONS, SqlBaseParserFUNCTIONS, SqlBaseParserFUNCTION, SqlBaseParserARRAY, SqlBaseParserMAP, SqlBaseParserSET, SqlBaseParserDEFINE, SqlBaseParserUNDEFINE, SqlBaseParserRESET, SqlBaseParserSESSION, SqlBaseParserKEY, SqlBaseParserSINK, SqlBaseParserSOURCE, SqlBaseParserPRIMARY, SqlBaseParserREPLACE, SqlBaseParserASSERT, SqlBaseParserADD, SqlBaseParserALTER, SqlBaseParserVARIABLES, SqlBaseParserPLUGINS, SqlBaseParserHEADERS, SqlBaseParserHEADER, SqlBaseParserSYSTEM, SqlBaseParserTIMEOUT, SqlBaseParserSCHEMA, SqlBaseParserSUBJECT, SqlBaseParserID, SqlBaseParserIF, SqlBaseParserIDENTIFIER, SqlBaseParserDIGIT_IDENTIFIER, SqlBaseParserQUOTED_IDENTIFIER, SqlBaseParserBACKQUOTED_IDENTIFIER, SqlBaseParserVARIABLE:
		localctx = NewLambdaContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1152)
			p.Identifier()
		}
		{
			p.SetState(1153)
			p.Match(SqlBaseParserLAMBDA_EXPRESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1154)
			p.Expression()
		}

	case SqlBaseParserT__2:
		localctx = NewLambdaContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1156)
			p.Match(SqlBaseParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1157)
			p.Identifier()
		}
		p.SetState(1162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == SqlBaseParserT__1 {
			{
				p.SetState(1158)
				p.Match(SqlBaseParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1159)
				p.Identifier()
			}

			p.SetState(1164)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1165)
			p.Match(SqlBaseParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1166)
			p.Match(SqlBaseParserLAMBDA_EXPRESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1167)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableNameContext is an interface to support dynamic dispatch.
type IVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsVariableNameContext differentiates from other interfaces.
	IsVariableNameContext()
}

type VariableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameContext() *VariableNameContext {
	var p = new(VariableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_variableName
	return p
}

func InitEmptyVariableNameContext(p *VariableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_variableName
}

func (*VariableNameContext) IsVariableNameContext() {}

func NewVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameContext {
	var p = new(VariableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_variableName

	return p
}

func (s *VariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIDENTIFIER, 0)
}

func (s *VariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterVariableName(s)
	}
}

func (s *VariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitVariableName(s)
	}
}

func (p *SqlBaseParser) VariableName() (localctx IVariableNameContext) {
	localctx = NewVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, SqlBaseParserRULE_variableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		p.Match(SqlBaseParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableValueContext is an interface to support dynamic dispatch.
type IVariableValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsVariableValueContext differentiates from other interfaces.
	IsVariableValueContext()
}

type VariableValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableValueContext() *VariableValueContext {
	var p = new(VariableValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_variableValue
	return p
}

func InitEmptyVariableValueContext(p *VariableValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_variableValue
}

func (*VariableValueContext) IsVariableValueContext() {}

func NewVariableValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableValueContext {
	var p = new(VariableValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_variableValue

	return p
}

func (s *VariableValueContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *VariableValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterVariableValue(s)
	}
}

func (s *VariableValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitVariableValue(s)
	}
}

func (p *SqlBaseParser) VariableValue() (localctx IVariableValueContext) {
	localctx = NewVariableValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, SqlBaseParserRULE_variableValue)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1173)
		p.Match(SqlBaseParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISourceNameContext is an interface to support dynamic dispatch.
type ISourceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsSourceNameContext differentiates from other interfaces.
	IsSourceNameContext()
}

type SourceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceNameContext() *SourceNameContext {
	var p = new(SourceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sourceName
	return p
}

func InitEmptySourceNameContext(p *SourceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_sourceName
}

func (*SourceNameContext) IsSourceNameContext() {}

func NewSourceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceNameContext {
	var p = new(SourceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_sourceName

	return p
}

func (s *SourceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SourceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterSourceName(s)
	}
}

func (s *SourceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitSourceName(s)
	}
}

func (p *SqlBaseParser) SourceName() (localctx ISourceNameContext) {
	localctx = NewSourceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, SqlBaseParserRULE_sourceName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1175)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type FloatLiteralContext struct {
	NumberContext
}

func NewFloatLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) FLOATING_POINT_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFLOATING_POINT_VALUE, 0)
}

func (s *FloatLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUS, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *SqlBaseParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, SqlBaseParserRULE_number)
	var _la int

	p.SetState(1189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(1177)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1180)
			p.Match(SqlBaseParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewFloatLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(1181)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1184)
			p.Match(SqlBaseParserFLOATING_POINT_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SqlBaseParserMINUS {
			{
				p.SetState(1185)
				p.Match(SqlBaseParserMINUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1188)
			p.Match(SqlBaseParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NullLiteralContext struct {
	LiteralContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	LiteralContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRING, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type VariableLiteralContext struct {
	LiteralContext
}

func NewVariableLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableLiteralContext {
	var p = new(VariableLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *VariableLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableLiteralContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIABLE, 0)
}

func (s *VariableLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterVariableLiteral(s)
	}
}

func (s *VariableLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitVariableLiteral(s)
	}
}

type NumericLiteralContext struct {
	LiteralContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	LiteralContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *SqlBaseParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, SqlBaseParserRULE_literal)
	p.SetState(1196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SqlBaseParserNULL:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1191)
			p.Match(SqlBaseParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserMINUS, SqlBaseParserINTEGER_VALUE, SqlBaseParserDECIMAL_VALUE, SqlBaseParserFLOATING_POINT_VALUE:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1192)
			p.Number()
		}

	case SqlBaseParserTRUE, SqlBaseParserFALSE:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1193)
			p.BooleanValue()
		}

	case SqlBaseParserSTRING:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1194)
			p.Match(SqlBaseParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case SqlBaseParserVARIABLE:
		localctx = NewVariableLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1195)
			p.Match(SqlBaseParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	MAP() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	DATE() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	ZONE() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	SET() antlr.TerminalNode
	RESET() antlr.TerminalNode
	IF() antlr.TerminalNode
	SOURCE() antlr.TerminalNode
	SINK() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	EMIT() antlr.TerminalNode
	CHANGES() antlr.TerminalNode
	FINAL() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	ASSERT() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	ADD() antlr.TerminalNode
	HEADER() antlr.TerminalNode
	HEADERS() antlr.TerminalNode
	GRACE() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	DEFINE() antlr.TerminalNode
	UNDEFINE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TIMEOUT() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SUBJECT() antlr.TerminalNode
	ID() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SqlBaseParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SqlBaseParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSHOW, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTABLES, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMNS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCOLUMN, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITIONS, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTIONS, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFUNCTION, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSESSION, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSTRUCT, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMAP, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserARRAY, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPARTITION, 0)
}

func (s *NonReservedContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTEGER, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDATE, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMESTAMP, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserINTERVAL, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserZONE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserYEAR, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMONTH, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDAY, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHOUR, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserMINUTE, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSECOND, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEXPLAIN, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserANALYZE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTYPES, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSET, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserRESET, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserIF, 0)
}

func (s *NonReservedContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSOURCE, 0)
}

func (s *NonReservedContext) SINK() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSINK, 0)
}

func (s *NonReservedContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPRIMARY, 0)
}

func (s *NonReservedContext) KEY() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserKEY, 0)
}

func (s *NonReservedContext) EMIT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserEMIT, 0)
}

func (s *NonReservedContext) CHANGES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserCHANGES, 0)
}

func (s *NonReservedContext) FINAL() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserFINAL, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserESCAPE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserREPLACE, 0)
}

func (s *NonReservedContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserASSERT, 0)
}

func (s *NonReservedContext) ALTER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserALTER, 0)
}

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserADD, 0)
}

func (s *NonReservedContext) HEADER() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHEADER, 0)
}

func (s *NonReservedContext) HEADERS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserHEADERS, 0)
}

func (s *NonReservedContext) GRACE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserGRACE, 0)
}

func (s *NonReservedContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPERIOD, 0)
}

func (s *NonReservedContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserDEFINE, 0)
}

func (s *NonReservedContext) UNDEFINE() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserUNDEFINE, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserVARIABLES, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserPLUGINS, 0)
}

func (s *NonReservedContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSYSTEM, 0)
}

func (s *NonReservedContext) TIMEOUT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserTIMEOUT, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSCHEMA, 0)
}

func (s *NonReservedContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserSUBJECT, 0)
}

func (s *NonReservedContext) ID() antlr.TerminalNode {
	return s.GetToken(SqlBaseParserID, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SqlBaseListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *SqlBaseParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, SqlBaseParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1198)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-4539347082556731648) != 0) || ((int64((_la-76)) & ^0x3f) == 0 && ((int64(1)<<(_la-76))&-4161291112904425469) != 0) || ((int64((_la-140)) & ^0x3f) == 0 && ((int64(1)<<(_la-140))&8191) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *SqlBaseParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 42:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 45:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 46:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 51:
		var t *TypeContext = nil
		if localctx != nil {
			t = localctx.(*TypeContext)
		}
		return p.Type__Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SqlBaseParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SqlBaseParser) Type__Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
